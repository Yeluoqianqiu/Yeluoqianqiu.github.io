为什么需要包装类：基本数据类型不是引用类型，不继承自Object，引入包装类可以实现面向对象的完整性。

| 基本数据类型 | 默认值 | 包装类    | 默认值 |
| ------------ | ------ | --------- | ------ |
| byte         | 0      | Byte      | null   |
| -            | -      | -         | -      |
| short        | 0      | Short     | null   |
| int          | 0      | Integer   | null   |
| long         | 0L     | Long      | null   |
| float        | 0.0    | Float     | null   |
| double       | 0.0    | Double    | null   |
| boolean      | false  | Boolean   | null   |
| char         | '\0'   | Character | null   |

Byte/Short/Integer/Long/Float/Double类都继承于Number类。

## 缓存池

Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。 为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。

两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。

```
        Integer i1 = 33;
        Integer i2 = 33;
        System.out.println(i1 == i2);// 输出 true
        Integer i11 = 333;
        Integer i22 = 333;
        System.out.println(i11 == i22);// 输出 false
        Double i3 = 1.2;
        Double i4 = 1.2;
        System.out.println(i3 == i4);// 输出 false
```

在 jdk 1.8 所有的数值类缓存池中，Integer 的缓存池 IntegerCache 很特殊，这个缓存池的下界是 - 128，上界默认是 127，但是这个**上界是可调的** ，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓存池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。

> [StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123](https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123)
>

## 自动装箱和自动拆箱

* 装箱：将基本数据类型转化为对应的包装类
* 拆箱：将包装类转换为对应的基本数据类型

```
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 x.intValue()
```

new Integer(123) 与 Integer.valueOf(123) 的区别在于：

* new Integer(123) 每次都会新建一个对象；
* Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

```
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在 Java 8 中，Integer 缓存池的大小默认为 -128~127。

```
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}
```

编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。

```
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

Integer 比较更丰富的一个例子:

```
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));     Copy to clipboardErrorCopied
```

结果：

```
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   trueCopy to clipboardErrorCopied
```

解释：语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

## 字符串与包装类或基本数据类型的转换

### 字符串转换为基本数据类型或包装类

* 通过包装类的构造器。如：

```
int i = new Integer("12");
Integer int1 = new Integer("12");
```

* 通过包装类的`parseXxx(String s)`静态方法。【推荐】如：

```
Float f = Float.parseFloat("12.1");
boolean b = Boolean.parseBoolean("truelala");//任何非"true"的串都表示false
```

### 基本数据类型或包装类转换为字符串

* 调用字符串重载的valueOf()方法：`String float_str = String.valueOf(2.34f);`
* 使用空字符串+数据的形式【推荐】：`string int_str = 5 + "";`
* 调用包装类的toString()方法【推荐】：

```
Boolean bool = true;
String boolean_str = bool.toString();
```