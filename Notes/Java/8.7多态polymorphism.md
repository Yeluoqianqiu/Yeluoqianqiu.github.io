### 多态的概念

Java中的多态指的是**对象的多态性** ，程序中所定义的引用变量所指向的具体类型和通过该引用变量调用的方法在编程时并不确定，而是在程序运行期间才确定。

简单来说就是：子类可以看作是特殊的父类，即**父类的引用指向了子类对象** 【向上转型upcasting】

### 多态的作用

提高代码的通用性，常称作接口重用

### 多态的使用前提

①存在继承关系的多个类 ②存在方法的重写

**多态体现在多个子类对父类的方法进行不同的重写。** 使得多个父类的引用分别指向不同的子类实例，调用同名同参方法时，可以产生不同的效果。

### 编译时类型、运行时类型与虚拟方法调用

Java引用变量有两个类型：**编译时类型** 和**运行时类型** 。编译时类型由**声明该变量时** 使用的类型决定，运行时类型由**实际赋给该变量的对象** 决定。**即：编译看左边，执行看右边。**

```
class Son extends Father{
    public void set() {
        System.out.println("son");
    }
  
    private static void main(String[] args){
        Father s = new Son();
        s.set(); //编译时报错:set() has private access，编译时看左边，Father的set()为private的，不能在其他类中调用
    }
}
class Father{
    private void set() {
        System.out.println("father");
    }
}
```

虚拟方法调用：子类定义了与父类同名同参的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的调用在编译期是无法确定的。

若编译时类型和运行时类型不一致，就出现了对象的多态性：

**在编译时，认为是调用父类的方法，在运行时，由于动态绑定，实际执行的是子类重写的方法。因此多态是运行时行为。**

**多态不适用于属性和子类的特有方法** 。属性没有虚拟调用一说，即使子类中存在与父类属性同名的属性，父类也无法对该属性访问。【内存中实际加载了子类特有的属性和方法，但是由于变量声明为父类类型，编译时，只能调用父类中的属性和方法，**要想调用子类特有的方法和属性，可使用强制类型转换向下转型** 】

### 从编译和运行的角度看方法的重载和重写

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。**它们的调用地址在编译期就绑定了** 。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法， 这称为**“早绑定”或“静态绑定”；**

而对于重写，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为**“晚绑定”或“动态绑定。**

### instanceof

a instanceof A用于检验a对象是否为A类型，返回值为boolean类型。

> 如果a instanceof b, b instanceof c, 则a instanceof c。
>

### 对象类型转换(casting)

Java对象的强制类型转换称为造型

* 从子类到父类的类型转换(向上转型)自动进行；
* 从父类到子类的类型转换(向下转型)通过强制类型转换；
* 无继承关系的类型之间进行类型转换是非法的，将引发ClassCastException异常，在转换类型前推荐使用instanceof进行检查