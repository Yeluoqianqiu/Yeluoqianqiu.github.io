## 1.Integer缓存池

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}
```

## 2.对++和--的深层次理解

1.第一层次：++i先计算后赋值，i++先赋值后计算

```java
public class Hello {
    public static void main(String[] args) {
        int i = 0;
        i = i++;
        System.out.println(i);
    }
}
//问题：int i = 0; i = i++; System.out.print(i)结果是多少？
//如果按照先赋值后计算理解，右边的i赋值给左边的i，右边的i再自加1,答案应该是1,但实际是0
```

2.第二层次：反编译上述过程的.class文件

```java
public class Hello {
    public Hello() {
    }

    public static void main(String[] args) {
        int i = 0;
        byte var10000 = i;
        int var2 = i + 1;
        i = var10000;
        System.out.println(i);
    }
}
```

可以看到有一个中间变量var10000中转了i的初始值，然后计算i + 1并赋值给var2，再将中间变量var10000赋值给左边的i。即右边所有计算都进行完成，才进行等号的赋值运算。并不是简单的"先赋值，后计算。"

3.第三层次：查看字节码

```java
L0
LINENUMBER 4 L0
ICONST_0 //1.内存中有一个int常量0
ISTORE 1 //2.将内存中的值(0)存入槽1(null -> 0)
L1
LINENUMBER 5 L1
ILOAD 1  //3.从槽1加载值到内存(0 -> 0)
IINC 1 1 //4.槽1值增加1(0 -> 1)
ISTORE 1 //5.将内存中的值(0)存入槽1(1 -> 0)
L2
LINENUMBER 6 L2
GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
ILOAD 1 //6.从槽1加载值到内存(0 -> 0)
INVOKEVIRTUAL java/io/PrintStream.println (I)V
L3
LINENUMBER 7 L3
RETURN //7.结束运行，返回
L4
LOCALVARIABLE args [Ljava/lang/String; L0 L4 0 //String[] args 关联槽0，生命周期L0 -> L4
LOCALVARIABLE i I L1 L4 1  //int i 关联槽1，生命周期L1 -> L4
MAXSTACK = 2
MAXLOCALS = 2
```

从字节码看，内存可看作中间变量，main方法中另有两个变量：args和i。

重点看生命周期L1，即`i = i++;`语句执行过程：先将i值载入内存，然后 i 自增1(但i自增后的值并没有载入内存)，接着又将内存中的值存到i中，即 i 最终值为0。

从第二层次和第三层次可以看出：赋值语句都是先将右边所有操作执行完，再进行赋值操作，且可以得知++和--并不是原子操作。