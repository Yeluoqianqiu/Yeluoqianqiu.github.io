## 1.

```
1.0/10与 1-9.0/10结果不一样
```

## 2.

```
short v1 = 3;
v1 = v1 - 2; //报错，因为强制类型转换后右边是int，左边v1是short，类型不匹配。
```

## 3.

```
int i = 10;
double j = 10.0;
System.out.println(i == j);//True自动类型提升
```

## 4.以下代码的输出为：

```
Object o1 = true ? new Integer(1) : new Double(2.0); 
System.out.println(o1); 
//很容易答1，其实是1.0,涉及到三目运算符的自动类型提升和自动拆箱等知识。
```

## 5.以下代码的输出各是：

```
public void method1() { 
    Integer i = new Integer(1); 
    Integer j = new Integer(1); 
    System.out.println(i == j);//false

    Integer m = 1; 
    Integer n = 1; 
    System.out.println(m == n);//true

    Integer x = 128; 
    Integer y = 128; 
    System.out.println(x == y);//false
}
//原因：Integer内部定义了IntergerCache结构，IntegerCache中定义了Integer[]，保存了从-128~127范围的整数【这些数使用频繁】。如果我们使用自动装箱的方式给Integer赋值，且赋值范围在-128~127时，可以直接使用数组中的元素，不会再new一个Integer对象，从而提高效率。超出这个范围是，自动装箱的方式给Integer赋值，会new一个Integer对象。
```

## 6.

```
public class Test{
    public static void main(String[] args){
        int a = 10;
        int b = 20;
        method(a, b);//需要在method方法被调用后，仅打印出a=100，b=200.请实现method方法的代码
        System.out.println("a="+a);
        System.out.println("b="+b);
    }
    public static void method(int a, int b){
        //请实现
    }
}
```

此题乍一看以为是值传递，但是method()方法中对a,b的修改不能作用到main()方法中的a,b。因此考虑偷鸡。

方法一：直接在method方法中输出题目要求的结果，然后调用System.exit()退出程序，就不会有别的代码执行了。

```
public static void method(int a, int b){
    a *= 10;
    b *= 20;
    System.out.println("a="+a);
    System.out.println("b="+b);
    System.exit(0);
}
```

方法二：重写输出方法

```
public static void method(int a, int b){
    PrintStream ps = new PrintString(System.out){
        @Override
        public void println(String x){
            if("a=10".equals(x))x = "a=100";
            else if("b=10".equals(x)) x = "b=200";
            super.println(x);
        }
    };
    System.setOut(ps);
}
```

## 7.对方法重写的深入理解

```
class Son extends Father{
    public void set() {
        System.out.println("son");
    }
}
 
public class Father{
    private void set() {
        System.out.println("father");
    }
    public static void main(String[] args) {
        Father s = new Son();
        s.set();//输出father而不是son，编译时看左边，为Father类，运行时，若子类重写了父类的set()方法，则绑定子类的set()，而此处Father的set()为private的，子类虽然有同名的set()，但不是对此方法的重写，因此，仍然调用父类的set()，故输出father.
    }
}
```

## 8.对多态的编译时类型和运行时类型的理解

```
class Son extends Father{
    public void set() {
        System.out.println("son");
    }
  
    private static void main(String[] args){
        Father s = new Son();
        s.set(); //编译时报错:set() has private access，编译时看左边，Father的set()为private的，不能在其他类中调用
    }
}

class Father{
    private void set() {
        System.out.println("father");
    }
}
```

## 9.

## 10.

凹凸函数与常识形状相反：凸函数是V字形，凹函数是

$\Lambda$型【助记：conVex concAve】

reduce()的两个坑：

```
protected void reduce(Text key, Iterable<TableBean> values, Context context) throws IOException, InterruptedException {
    String pName="";
    //坑1：iterable不能多次遍历【不在hadoop中是没问题的】
    for (TableBean value : values) {
        if("pd".equals(value.getFlag())){
            pName = value.getPname();
            break;
        }
    }
    //再次迭代，有可能为空，详见reduce join的小米 华为 格力 问题
    for (TableBean value : values) {
        if("order".equals(value.getFlag())){
            value.setPname(pName);

            //坑2：value是一个引用，如果没有每次将其指向的值中转，直接使用
            // context.write(value,NullWritable.get())，所有的量都指向了最后一个迭代值
            TableBean temp = new TableBean();
            try {
                BeanUtils.copyProperties(temp, value);
            } catch (Exception e) {
                e.printStackTrace();
            }
            context.write(temp,NullWritable.get());
        }
    }
}
```

谨防java引用类型浅复制陷阱。

hive substring()起始下标为1，也可以用0，且为左闭右闭区间，如substring(str,1,5)与substring(str,0,5)一致