### 继承的格式：

```
class 子类名 extends 父类名{
   ...
}
```

父类也称为基类、超类，子类又称为派生类。

子类的特点：**继承了父类的所有属性和方法，但只能访问父类的非私有成员** 。子类继承父类之后，可以声明自己特有的属性和方法，实现功能的扩展

### 继承的注意事项：

* 一个父类可以被多个子类继承，但一个类只能有一个父类(**单继承** )
* Java支持多重继承，如：`Son extends Father{};Father extends GrandFather{}`;
* 如果没有显式地声明一个类的父类，其默认继承于java.lang.Object类

### 继承的好处和弊端

好处：

* 提高了代码的复用性(多个类相同的成员可以放到一个父类中，然后继承这个父类)
* 便于功能的扩展
* 便于维护(如果某个共有方法的代码需要修改，只修改父类即可)
* 是多态的基础

弊端：

* 继承让类与类之间产生了关系，违背了低耦合的宗旨，当父类发生变化时子类也不得不跟着变化，削弱了子类的独立性

### 继承中构造方法的访问特点

* 构造器的首行必然是`super(…);`和`this(…);`二者选一(不能同时出现)【一个类中有N个构造器，其中最多可以有N-1个首行为this()，**至少有一个首行是super()** 】
* 父类的构造器不会被子类继承，但至少有一个会被子类访问。
* **子类中的所有构造方法，默认都会隐式访问父类的无参构造方法** 【除非显式给出`this(…);`或`super(…);`】。原因：子类会继承父类中的数据，可能还会使用父类的数据，因此**初始化子类之前要先初始化父类** 。

### 变量和成员方法的访问顺序

变量：子类局部-->子类成员-->父类成员-->父类的父类

如：

```
class Parent{
    int age = 10; //1
}

class Son extends Parent{
    int age = 20; //2
    public void show(){
        int age = 30; //3
        System.out.println(age);
    }
}

public static void main(String[] args){
    Son s = new Son();
    s.show();
}
//输出30(子类的局部变量)，若没有语句3，输出20(子类成员变量)；若没有语句2和语句3，输出10(父类成员变量)。若想在show()中同时输出这3个变量，代码为：
public void show{
    int age = 30;
    System.out.println(age);
    System.out.println(this.age);
    System.out.println(super.age);
}
```

成员方法：子类-->父类-->父类的父类

在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

* this.func(this)
* super.func(this)
* this.func(super)
* super.func(super)

```
/*
    A
    |
    B
    |
    C
    |
    D
 */


class A {

    public void show(A obj) {
        System.out.println("A.show(A)");
    }

    public void show(C obj) {
        System.out.println("A.show(C)");
    }
}

class B extends A {

    @Override
    public void show(A obj) {
        System.out.println("B.show(A)");
    }
}

class C extends B {
}

class D extends C {
}
```

```
public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
```

### this和super

this是本类对象的引用，super是本类的父类的引用（不仅限于直接父类）。

|            | this                                                   | super                                          |
| ---------- | ------------------------------------------------------ | ---------------------------------------------- |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 访问父类中的非私有属性                         |
| -          | -                                                      | -                                              |
| 调用方法   | 调用本类中的方法，如果本类没有此方法则从父类中继续查找 | 调用父类中的非私有方法                         |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类非私有构造器，必须放在子类构造器的首行 |

=**this和super都不能出现在static修饰的方法中。**=

### 方法重写(override)

指子类继承父类时，对父类中已有的非私有非静态方法的重新实现，两者具有**相同的方法名和形参列表** 。

父类中的final方法不允许被重写，父类与子类存在的同名同参的private 或static方法不是重写。

> 父类的private或static方法，允许在子类中存在任意权限的同名方法，但两者毫无相干，不属于重写。
>

```
class Son extends Father{
    public void set() {
        System.out.println("son");
    }
}
 
public class Father{
    private void set() {
        System.out.println("father");
    }
    public static void main(String[] args) {
        Father s = new Son();
        s.set();//输出father而不是son，编译时看左边，为Father类，运行时，若子类重写了父类的set()方法，则绑定子类的set()，而此处Father的set()为private的，子类虽然有同名的set()，但不是对此方法的重写，因此，仍然调用父类的set()，故输出father.
    }
}
```

可以用注解 `@Override`检验重写方法是否正确。如：打算重写某一个方法，但方法名输错了，在父类中没有对应的方法名，注解下的代码就会报告错误信息。

为了满足里式替换原则，重写有以下三个限制：

* **子类方法访问权限不小于父类方法的访问权限**
* 子类方法的返回类型必须是父类方法的返回类型或其子类

> 父类方法返回值为基本数据类型或void，子类方法的返回值必须是同类型
>
> 父类方法返回值是引用类型A，子类方法的返回值可以是A或A的子类
>

* 子类方法抛出的异常必须是父类方法抛出的异常类型或其子类

以上三点用于确保可以使用父类实例的地方，都可以使用子类实例去代替，即多态。

#### 重载和重写

重载发生在一个类中的多个同名方法之间，重写发生在父类和子类的同名方法之间。

重载发生在编译期间，重写发生在运行期间。

重写需要满足三个里氏替换原则，final方法不能被重写，父子类同名的private/static方法不是重写

重载要求同名方法的参数类型、个数或顺序至少有一个不同。

具体见CSNote.

### 子类实例化的全过程

* 从结果上看：子类继承父类以后，就获得了父类的属性和方法；创建子类对象时，其堆空间中包含了父类的所有成员【私有成员也存在，只是不能访问】
* 从过程上看：通过子类构造器创建子类对象时，一定会间接或直接地调用父类的构造器，进而调用父类的父类的构造器，直到java.lang.Object类中的无参构造器为止。正因为加载过所有父类的结构，子类空间中才有父类的成员。
* 但须明确：创建子类对象时，仅是调用了父类的构造器，自始至终只创建了一个对象。

### 动态绑定

Java中**成员方法** 有动态绑定机制(属性没有)：JVM会将正在执行的方法与当前被调用对象的实际内存进行绑定。如：子类A继承于父类B，若子类重写了父类的func()方法，调用子类A的实例a.func()时，调用的是子类的重写方法；若子类没有重写父类的func()方法，调用子类A的实例a.func()时，调用的是父类的方法。一个有趣的例子：

```
public class Test1 {
    public static void main(String[] args) {
        AAA aaa = new BBB();
        System.out.println(aaa.getResult());  //30
    }
}

class AAA {
    public int i = 10;
    public int getResult() {
        return getI() + 10;
    }

    public int getI() {
        return i;
    }
}

class BBB extends AAA {
    public int i = 20;
    public int getI() {
        return i;
    }
}
//子类BBB继承于父类AAA，并重写了getI()方法，但没有重写getResult()方法，在main()方法中得到了一个BBB的实例aaa(多态)，调用aaa.getResult()时，首先判断aaa自身是否有getResult()方法，发现没有，继而调用父类的getResult()方法，而父类的getResult()方法中又调用了一个getI()方法，其实所有的成员方法都省略了this.前缀，而this在这里指的是aaa, 首先判断aaa自身是否有getI()，发现有，则这个getI()是重写的getI()，在重写的getI()里执行return i; 其实是return this.i; 即aaa自己的i, 若aaa没有i才会调用父类的i。
```