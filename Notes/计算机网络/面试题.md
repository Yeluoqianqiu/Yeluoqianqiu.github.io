## 1、OSI与TCP/IP各层的结构与功能,都有哪些协议?

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。

![image](https://Yeluoqianqiu.github.io/assets/20210710105104.png)

结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。

传输层及以上是**进程之间**的通信，传输层以下是**主机之间**的通信。

### 1.1 应用层

应用层(application-layer）用于**具体网络应用**之间的交互和通信。应用层协议定义的是网络应用间的通信和交互的规则。**对于不同的网络应用需要不同的应用层协议**。

在互联网中应用层协议很多，如：

- 用于域名和ip地址相互映射的**域名系统 DNS**
- 用于网页的**超文本传输协议** **HTTP**
- **简单邮件传输协议** **SMTP**

应用层交互的数据单元称为**报文**。

**域名系统**

> 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将**域名和IP地址相互映射的一个分布式数据库**，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

**HTTP协议**

> 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）

### 1.2 传输层

传输层(transport layer)主要负责提供两台主机**进程之间**的**通用**的数据传输服务。应用进程利用该服务传送应用层报文。

- “通用”是指并**不针对某一个特定的网络应用**，而是多种应用可以使用同一个运输层服务。
- 由于一台主机可同时运行多个线程，因此传输层有**复用和分用**的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用则是传输层把收到的信息分别交付给应用层中的不同进程。

传输层主要使用以下两种协议:

- **传输控制协议**(Transmission Control Protocol, **TCP**)：提供**面向连接**的，**可靠的**数据传输服务。
- **用户数据报协议(**User Datagram Protocol, **UDP**)：提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

### 1.3 网络层

互联网是由大量的异构(heterogeneous)网络通过路由器(router)相互连接起来的。**网络层的任务是实现异构网络的互联、分组路由选择和分组转发，以及分组的拥塞控制确保数据及时传送。**

网络层把传输层的报文段或用户数据报封装成**IP数据报**，由于链路层**最大传输单元MTU**的限制，IP数据报切分为**分片(分组)**进行传送。

网络层协议：无连接的**网际协议**(Internet Protocol)和许多**路由选择协议(RIP/OSPF)**。

### 1.4 数据链路层

数据链路层(data link layer)**给网络层的IP 数据报添加首部和尾部，组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的**控制信息**（如同步信息，地址信息，差错控制(包括检错和纠错)等）。

### 1.5 物理层

物理层(physical layer)用于实现网络节点之间**比特流的透明传输**，尽可能屏蔽掉具体传输介质和物理设备的差异。

在物理层上所传送的数据单位是比特。

## 2、TCP(⭐)

### 2.1 三次握手

### 2.2 四次挥手

### 2.3 TCP、UDP 协议的区别

### 2.4 TCP 协议如何保证可靠传输(被考过)

## 3、HTTP

### 3.1 HTTP请求方法和状态码

| 方法     | 含义                                                                             |
| -------- | -------------------------------------------------------------------------------- |
| OPTION   | 获取URL支持的方法，返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容             |
| **GET**  | 获取URL指定的资源                                                                |
| HEAD     | 获取URL指定资源的首部，不含主体实体，主要用于确认URL的有效性以及资源更新的时间等 |
| **POST** | 向服务器传输数据                                                                 |
| PUT      | 上传文件，自身不带验证机制，存在安全问题，一般不使用                             |
| DELETE   | 删除文件，也不带验证机制，一般不使用                                             |
| TRACE    | 返回通信的路径，易受到XST(cross site tracing)攻击，一般不使用                    |
| CONNECT  | 要求在与代理服务器通信时建立隧道，使用 SSL/TSL协议把通信内容加密后经网络隧道传输 |

状态码：总共5大类，33种

| 状态码 | 含义                                    |
| ------ | --------------------------------------- |
| 1XX    | Informational通知，如请求收到或正在处理 |
| 2XX    | Success成功，如请求成功，已创建，已完成 |
| 3XX    | Redirection重定向                       |
| 4XX    | Client Error客户端错误                  |
| 5XX    | Server Error服务器错误                  |

常见状态码：

- **100 Continue**：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
- **200 OK**：请求成功
- **301 Moved Permanently**：永久性重定向
- **302 Found**：临时性重定向
- **303 See Other**：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源
- - 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301/302/303 状态下的重定向把 POST 方法改成 GET 方法
- **307 Temporary Redirect**：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法
- **400 Bad Request**：请求报文中存在语法错误
- **401 Unauthorized**：需要认证。如果之前已进行过一次请求，则表示用户认证失败
- **403 Forbidden**：请求被拒绝
- **404 Not Found**：请求的资源未找到
- **500 Internal Server Error**：服务器正在执行请求时发生错误
- **503 Service Unavailable**：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

### 3.2 GET和POST的区别

- get从服务器获取数据，post向服务器传输数据
- get请求直接在url中可以查看到，post请求则放在请求体中，不会被url劫持，更安全
- get提交数据一般不超过1024kb，post则没有限制
- 请求缓存：post可以，get不可以，因为get是url请求，没有请求体，无法缓存
- 收藏书签：get可以，post可以，post是方法体，无法收藏

### 3.3 在浏览器中输入url到显示网页的过程(面试常客)

### 3.4 长连接、短连接

### 3.5 HTTP是不保存状态的协议,如何保存用户状态?

HTTP 是一种无状态（stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是**内存和数据库**(比如使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。

### 3.6 Cookie和Session

Cookie 和 Session都是用来**跟踪浏览器用户身份的会话方式**，但是两者的应用场景不太一样。

**Cookie 一般用于在客户端保存用户信息，**比如：

- ①我们**在 Cookie 中保存已经登录过的用户信息**，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；
- ②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；
- ③登录一次网站后访问网站其他页面不需要重新登录。

**
**

**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以**标识这个用户并且跟踪这个用户**了。

**Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。**相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### 3.7 URI和URL的区别是什么?

### 3.8 HTTP 和 HTTPS 的区别？

**端口** ：HTTP的URL由“http://”起始且默认使用**端口80**，而HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)的URL由“https://”起始且默认使用**端口443**。

**安全性和资源消耗：** HTTP协议直接运行在TCP协议之上，传输的内容都是明文。HTTPS则是在TCP协议之上添加了SSL(Secure Socket Layer)协议，而HTTPS运行在SSL之上。所有传输的内容都经过**对称加密**，而对称加密的密钥用服务器方的证书进行了**非对称加密**。以此保证了HTTPS的高安全性，但是 HTTPS会比HTTP**耗费更多服务器资源**。

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

> 非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。