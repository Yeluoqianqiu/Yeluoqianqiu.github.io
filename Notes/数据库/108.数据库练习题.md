### 第一题

有如下数据：

| userId | visitDate | visitCount |
| ------ | --------- | ---------- |
| u01    | 2017/1/21 | 5          |
| u02    | 2017/1/23 | 6          |
| u03    | 2017/1/22 | 8          |
| u04    | 2017/1/20 | 3          |
| u01    | 2017/1/23 | 6          |
| u01    | 2017/2/21 | 8          |
| u02    | 2017/1/23 | 6          |
| u01    | 2017/2/22 | 4          |

要求使用SQL统计出每个用户的累积访问次数，如下表所示：

| 用户id | 月份    | 小计 | 累积 |
| ------ | ------- | ---- | ---- |
| u01    | 2017-01 | 11   | 11   |
| u01    | 2017-02 | 12   | 23   |
| u02    | 2017-01 | 12   | 12   |
| u03    | 2017-01 | 8    | 8    |
| u04    | 2017-01 | 3    | 3    |

准备数据：

```sql
create table first(userid string,visitDate String,visitCount string);
insert into table first values('u01','2017/1/21','5');
insert into table first values('u02','2017/1/23','6');
insert into table first values('u03','2017/1/22','8');
insert into table first values('u04','2017/1/20','3');
insert into table first values('u01','2017/1/23','6');
insert into table first values('u01','2017/2/21','8');
insert into table first values('u02','2017/1/23','6');
insert into table first values('u01','2017/2/22','4');
```

解答：

```mysql
# 1）修改数据格式
select
     userId,
     date_format(regexp_replace(visitDate,'/','-'),'yyyy-MM') mn,
     visitCount
from
     action;t1

# 2）计算每人单月访问量
select
    userId,
    mn,
    sum(visitCount) mn_count
from
    t1
group by userId,mn;t2

# 3）按月累计访问量
select
    userId,
    mn,
    mn_count,
    sum(mn_count) over(partition by userId order by mn)
from t2;

# 最终SQL
select
    userId,
    mn,
    mn_count,
    sum(mn_count) over(partition by userId order by mn)
from 
(   select
        userId,
        mn,
        sum(visitCount) mn_count
    from
         (select
             userId,
             date_format(regexp_replace(visitDate,'/','-'),'yyyy-MM') mn,
             visitCount
         from
             action)t1
group by userId,mn)t2;
```

### 第二题

有50W个京东店铺，每个顾客访客访问任何一个店铺的任何一个商品时都会产生一条访问日志，访问日志存储的表名为Visit，访客的用户id为user_id，被访问的店铺名称为shop，请统计：

1）每个店铺的UV（访客数）

2）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数

```
u1	a
u2	b
u1	b
u1	a
u3	c
u4	b
u1	a
u2	c
u5	b
u4	b
u6	c
u2	c
u1	b
u2	a
u2	a
u3	a
u5	a
u5	a
u5	a
```

建表：

```sql
create table visit(user_id string,shop string) 
row format delimited fields terminated by '\t';
--根据自己存储的位置将此表导入。
```

1）每个店铺的UV（访客数）

```sql
select shop,count(distinct user_id) from visit group by shop;
```

2）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数

```mysql
#（1）查询每个店铺被每个用户访问次数
select shop,user_id,count(*) ct
from visit
group by shop,user_id;t1

#（2）计算每个店铺被用户访问次数排名
select shop,user_id,ct,rank() over(partition by shop order by ct) rk
from t1;t2

#（3）取每个店铺排名前3的
select shop,user_id,ct
from t2
where rk<=3;

#（4）最终SQL
select shop,user_id,ct
from (select shop,user_id,ct,rank() over(partition by shop order by ct) rk
	from 
		(select shop,user_id,count(*) ct
			from visit
			group by shop,user_id
        )t1
     )t2
where rk<=3;
```

### 第三题

已知一个表ORDER，有如下字段:Dt，Order_id，User_id，amount。请给出sql进行统计:数据样例:2017-01-01,10029028,1000003251,33.57。

建表：

```sql
create table order_tab(
    dt string,order_id string,user_id string,amount decimal(10,2)) 
row format delimited fields terminated by '\t';
```

1）给出 2017年每个月的订单数、用户数、总成交金额。

```mysql
select
   date_format(dt,'yyyy-MM'),
   count(order_id),
   count(distinct user_id),
   sum(amount)
from order_tab
where date_format(dt,'yyyy') = '2017'
group by date_format(dt,'yyyy-MM');
```

2）给出2017年11月的新客数(指在11月才有第一笔订单)

```sql
select
   count(user_id)
from
   order_tab
   group by user_id
having date_format(min(dt),'yyyy-MM')='2017-11';
```

### 第四题

有日志如下，请求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）

```
日期 用户 年龄
2019-02-11,test_1,23
2019-02-11,test_2,19
2019-02-11,test_3,39
2019-02-11,test_1,23
2019-02-11,test_3,39
2019-02-11,test_1,23
2019-02-12,test_2,19
2019-02-13,test_1,23
2019-02-15,test_2,19
2019-02-16,test_2,19
```

建表：

```sql
create table user_age(dt string,user_id string,age int)
row format delimited fields terminated by ',';
```

1）按照日期以及用户分组，按照日期排序并给出排名

```sql
--此版本会导致笛卡尔积
select total,total_avg_age,active,active_avg_age 
from(select count(*) total, avg(age) total_avg_age 
     from (select distinct user_id,age from user_age)
     t1)t2 
     join 
     (select count(distinct user_id) active,avg(age) active_avg_age
     from (select dt,lead(dt,1,'2099-12-31') 
           over(partition by user_id order by dt)next, user_id,age from user_age)t3 
      where date_add(dt,1) = next)t4;
--不会导致笛卡尔积的版本
select sum(total) total, sum(total_avg_age) total_avg_age, 
sum(active) active, sum(active_avg_age) active_avg_age from 
(select count(*) total, avg(age) total_avg_age,0 active,0 active_avg_age 
     from (select distinct user_id,age from user_age)
     t1
     union select 0 total, 0 total_avg_age, count(distinct user_id) active,avg(age) active_avg_age
     from (select dt,lead(dt,1,'2099-12-31') 
           over(partition by user_id order by dt)next, user_id,age from user_age)t2 
      where date_add(dt,1) = next) t3;
```

### 第五题

订单改派，以下为ordertable表，orderid表示当前订单id，lastorderid表示改派之前的订单id，一个订单最多可以改派3次，如1->2->4->7，请求出订单的初始id。

```
+---------+-------------+
| orderid | lastorderid |
+---------+-------------+
|      10 |           9 |
|       8 |           6 |
|       9 |           5 |
|       6 |           3 |
|       7 |           4 |
|       4 |           2 |
|       2 |           1 |
+---------+-------------+
```

```mysql
-- 1.三个相同的表left join，连接条件是t1.lastorderid = t2.orderid,t2.lastorderid = t3.orderid
select t1.orderid o1, t1.lastorderid l1, t2.orderid o2, t2.lastorderid l2, t3.orderid o3, t3.lastorderid l3 
from ordertable t1 left 
join  ordertable t2 on t1.lastorderid = t2.orderid left 
join ordertable t3 on t2.lastorderid = t3.orderid;temp
+------+------+------+------+------+------+
| o1   | l1   | o2   | l2   | o3   | l3   |
+------+------+------+------+------+------+
|    7 |    4 |    4 |    2 |    2 |    1 |
|   10 |    9 |    9 |    5 | NULL | NULL |
|    8 |    6 |    6 |    3 | NULL | NULL |
|    4 |    2 |    2 |    1 | NULL | NULL |
|    9 |    5 | NULL | NULL | NULL | NULL |
|    6 |    3 | NULL | NULL | NULL | NULL |
|    2 |    1 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
-- 2.使用ifnull(l3,l2)实现：若没有改派3次则使用l2,若没有改派2次则使用l1
select o1 currentOrderId, ifnull(ifnull(l3,l2),l1) originalOrderId
from (
    select t1.orderid o1,t1.lastorderid l1, t2.lastorderid l2, t3.lastorderid l3 
    from ordertable t1 
    left join ordertable t2 on t1.lastorderid = t2.orderid 
    left join ordertable t3 on t2.lastorderid = t3.orderid) temp;
+----------------+-----------------+
| currentOrderId | originalOrderId |
+----------------+-----------------+
|              7 |               1 |
|             10 |               5 |
|              8 |               3 |
|              4 |               1 |
|              9 |               5 |
|              6 |               3 |
|              2 |               1 |
+----------------+-----------------+
```