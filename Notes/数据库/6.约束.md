数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。数据的完整性要从以下四个方面考虑：

- 实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录
- 域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女”
- 引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门
- 用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。

根据约束的特点，分为几种：

- 键约束：主键约束、外键约束、唯一键约束 【MySQL会自动为键约束添加索引】
- 非空约束：not null
- 检查约束：check
- 缺省约束：default

查看某个表的约束：

```mysql
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';
```

### 主键约束 PRIMARY KEY

关键字：primary key

特点：主键约束列的值必须是非空且唯一的。

作用：保证实体完整性，即表中不会出现两条相同的记录

要求：每一张表都必须有且仅有一个主键约束

分类：单列主键约束 复合主键约束

> 主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。
>

创建主键约束：

- 在建表时添加：
  ```mysql
    create table 【数据库名.】表名(
    	字段1 数据类型 primary key,
    	字段2 数据类型,
    	....
    );

    create table 【数据库名.】表名(
    	字段1 数据类型,
    	字段2 数据类型,
    	....,
    	primary key(字段1)
    );
  ```
- 在建表后添加：
  ```mysql
    alter table 表名 add primary key(列);
  ```

> 创建主键约束后，系统会自动创建**主键索引**，主键索引名一定为PRIMARY.
>

删除主键约束：

```mysql
alter table 表名 drop primary key;
```

> 删除主键约束会直接删除主键索引，**删除主键约束后，非空限制还存在**。
>

### 唯一键约束

关键字：unique [key]

特点：唯一键指定的列，值唯一，不能重复，但可为空

作用：限制主键以外的列，值的唯一性

分类：单列唯一  复合唯一

> 主键和唯一键的区别：
>
> - 主键不能为空，唯一键可以为空
> - 一个表只能有一个主键，可以有多个唯一键
>

创建唯一键：

- 在建表时添加：
  ```mysql
    create table 【数据库名.】表名(
    	列名1 数据类型 unique,
    	列名2 数据类型,
    	....
    );

    create table 【数据库名.】表名(
    	列名1 数据类型,
    	列名2 数据类型,
    	....,
    	[constraint 约束名] unique [key](列名1)
    );
  ```
- 在建表后添加：
  ```mysql
    alter table 表名 add unique [key] (列);
  ```

> 系统会为唯一约束的列创建一个**唯一索引**，单列唯一索引名默认为列名，多列唯一索引名默认为第一个列名。
>

删除唯一键：通过删除唯一索引的方式：

`alter table 表名 drop index 唯一索引名;`

> 注意删除唯一键不适用的drop unique，而是drop index。
>
> 如果忘记了索引名，可以通过`show index from 表名；`查看。
>

### 外键约束【了解】

外键约束用于保证两个表之间(或自己与自己)的参照完整性。

> 外键约束不是必须的，而且现在很多大的公司，数据量比较大时，不建议在数据库层面使用外键，因为这样效率低，可以把数据的约束转移到代码层面实现。
>

关键字：foreign key

特点：

- 约束的是两张表或一张表和其自身的关系，被参考表称为主表(父表)，建立外键的表称为从表(子表)
- 主表的被参考列必须是键列：主键、唯一键或外键
- 主表的被参考列与子表的参考列，名字可以不同，但数据类型必须相同
- **从表的外键值要么为空，要么必须存在于主表的被参考列中**
- 一个表可以有多个外键

主表和从表的相互制约：

- 建表：先建立主表，再建立从表
- 删除表：存在被参考列的表不能删除，除非先删除从表，才能删除主表
- 添加或修改从表的记录时，外键列的值必须存在于主表的被引用列的值中。
- 删除或修改主表的记录时：
  -   - 创建外键约束时，主从表之间默认是**"严格"策略**(restrict)。主表被引用列的值若正在被从表引用，不能被删除，除非先删除所有引用该值的从表的数据。
  -   - 创建外键时，指定了**“级联”策略**，可以做到级联删除或级联修改：删除或修改主表，子表相应位置会连带修改。
    ```mysql
        [constraint 约束名]foreign key(列) references 主表名(被参考列)[on update cascade][on delete cascade]; 
    ```
  -   - 创建外键时，指定了**“置空”策略**，可以做到置空删除或置空修改：删除或修改主表，子表相应位置会置空【若该列存在非空约束则报错】。
    ```mysql
        [constraint 约束名]foreign key(列) references 主表名(被参考列)[on update set null][on delete set null];
    ```

> 外键约束最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式
>

创建外键：

- 建表时添加外键：
  ```mysql
    [constraint 约束名]foreign key (列) references 主表名(被参考列)[on update restrict] [on delete restrict];
  ```
- 建表后添加外键：
  ```mysql
    [constraint 约束名]alter table 表名 add foreign key(列) references 主表(被引用列)[on update restrict] [on delete restrict];
  ```

> 创建外键约束时，若未指定默认外键约束名，会自动生成一个形如student_ibfk_1的外键约束名。
>
> 系统会为子表的外键列建立**普通索引**，普通索引名为列名，而非外键约束名。
>

删除外键：

alter table 表名 drop foreign key 外键约束名;

> 删除外键时，外键列上的普通索引不会跟着删除。
>

查看外键约束名:

select * from information_schema.table_constraints where table_name = '表名';

### 非空约束

非空约束用于约束某个字段的值不能为NULL

建表时添加：`列名 数据类型 not null;`

建表后添加：`alter table 表名 modify 列名 数据类型 not null；`

### 默认值约束

默认值约束：插入数据时，若某默认值约束列没有指定值，会用默认值填充。

建表时添加：`列名 数据类型 default 默认值;`

建表后添加：`alter table 表名 modify 类名 数据类型 default 默认值;`

```mysql
create table emp(
   id int primary key,
   ename varchar(20),
   gender varchar(10) default '男');
# 添加记录，完全添加时：有默认值的列可以用default代替，但不能不写
insert into emp values(1,'张三',default);# 等价于insert into emp values(1,'张三','男');
# 添加记录，部分添加时：有默认值的列可以不写
insert into emp(id,ename) values(1,'张三');
```

### 自增约束

自增约束用于产生唯一标识符或顺序值。

关键字：auto_increment

特点：

- 一个表只能有一个自增列
- 自增列必须是整型数据类型
- 自增列必须是主键或唯一键，且自增列必须非空

添加自增约束：

`列名 数据类型 primary key auto_increment;`

InnoDB表的自动增长列可以手动插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。如：

```mysql
create table emp(
    id int primary key auto_increment,
    ename varchar(20),
    gender varchar(10) default '男');

insert into emp values(100,'李四','男');
select * from emp where ename = '李四'; # (100,李四，男)
insert into emp values(null,'王五',default);
select * from emp where ename = '王五'; # (101,王五，男)
```

建表后添加自增约束：alter table 表名 modify 列名 数据结构 auto_increment;

### 检查约束

MySQL不支持check约束，使用check约束后无任何效果。

格式：`age tinyint check(age >20);` 或 `sex char(2) check(sex in(‘男’,’女’));`