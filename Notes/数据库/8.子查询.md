某种情况下，当进行一个查询时，需要的条件或数据要用另外一个select语句的结果，这个时候就要用到子查询。

为了给主查询（外部查询）提供数据而首先执行的查询（内部查询）被叫做子查询。

一般根据子查询的嵌入位置分为，where型子查询,from型子查询，exists型子查询。

### where型

子查询的结果作为外层的条件

- 单行子查询：子查询的结果为单行记录，使用单行操作符： =  >  >=  <  <=  <>
- 多行子查询：子查询的结果可以为多行记录，但必须是单列，使用多行操作符：ALL ANY IN  ALL和ANY要与单行操作符连用

```mysql
IN：满足任何一个
ANY:满足任意一个 id>ANY(1,2,3) 等价于`id>1 or id>2 or id>3`
ALL:满足所有     id>ALL(1,2,3) 等价于`id>1 and id>2 and id>3`
EXISTS:判断是否存在
```

示例：

```mysql
# 查询公司中工资最高的员工的编号和工资
select id, salary from employees where salary = (select max(salary) from employees);

select id, salary from employees where salary > ALL(select salary from employees);

#查询和孙红雷或李晨在一个部门的员工的全部信息
select * from employees where dept_id 
IN(select dept_id from employees where name = '孙红雷' or name = '李晨');

select * from employees where 
dept_id  =ANY(select dept_id form employees where name = '孙红雷' or name = "李晨");
```

### from型

将子查询的结果作为**临时表**供外层再次筛选

```mysql
# 找出比部门平均工资高的员工的编号和工资
SELECT t_employee.eid,basic_salary 
FROM t_salary INNER JOIN t_employee INNER JOIN (
	SELECT emp.dept_id AS did,AVG(s.basic_salary) AS avg_salary
	FROM t_employee AS emp,t_salary AS s
	WHERE emp.eid = s.eid
	GROUP BY emp.dept_id) AS temp
ON t_salary.eid = t_employee.eid AND t_employee.dept_id = temp.did
WHERE t_salary.basic_salary > temp.avg_salary;
```

### exists型

```mysql
#查询部门信息，该部门必须有员工
SELECT * FROM department 
WHERE EXISTS (SELECT * FROM employees WHERE employees.dept_id = department.did);
```