需要记住的语句：

| delimiter  //                           | 修改终止符为//                            |
| --------------------------------------- | ----------------------------------------- |
| declare 变量 变量类型 [default 默认值]; | 在函数或存储过程中声明变量                |
| set 变量 = 值;                          | 在函数或存储过程中赋值                    |
| set @t1 = 值;                           | 在函数或存储过程外赋值变量，@相当于引用。 |
| select  count(1) from t1;               | 查看t1表中有多少数据行                    |
| desc  t1;                               | 查看t1 表表头信息                         |

## 加速查找常见小技巧

1.减少请求的数据量：只返回必要的列，避免使用select *；只返回必要的行，过滤或使用limit限制返回的行数。

2.缓存重复查询的数据，但MySQL8.0以后取消了，将缓存功能交由redis等其他工具。

2.用count(1)或count(列)代替count(*)

3.创建表时尽量用char代替varchar

4.表的字段顺序，固定长度的字段优先

5.经常使用多条件查询时，用组合索引代替多个单列索引

6.尽量使用短索引

7.使用连接(join)来代替select from select

8.散列值的列不适合建索引，如：性别

9.limit分页要得当，分页越大速度越慢

## SQL语句执行较慢的三个原因

1.没有建立索引，或者索引失效导致

索引失效：比如like %，不符合最左前缀匹配，使用了or

2.锁等待

MyISAM 只支持表锁，而InnoDB虽然支持行锁，但行锁是基于索引加的锁，在执行更新操作时，条件索引失效了，那这个锁也会升级为表锁。即使索引没有失效，如果对一张表进行大量的更新操作， mysql认为这样会让事务的执行效率降低，到最后还是会导致性能下降，因此会升级为表锁。

3.不恰当的sql语句

比如只需要查询name,age，却使用了select *，或者order by 后面的字段并不是索引字段。

对分页查询的优化：

```sql
EXPLAIN SELECT * FROM `te_paper_record` ORDER BY id LIMIT 10000, 20;
EXPLAIN SELECT * FROM `te_paper_record` 
WHERE id >= ( SELECT id FROM `te_paper_record` 
             ORDER BY id LIMIT 10000, 1) LIMIT 20;
```

没有使用子查询执行了0.033s，使用了子查询优化后执行了0.007s。

当我们没有使用子查询时，查询到的10020行数据都返回回来了，接下来要对这 10020 行数据再进行过滤操作，而使用子查询则仅仅只返回我们需要的20行。

## 切分

### 水平切分

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg)

### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg)

### Sharding 策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

### Sharding 存在的问题

#### 1. 事务问题

使用分布式事务来解决，比如 XA 接口。

#### 2. 连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

#### 3. ID 唯一性

- 使用全局唯一 ID（GUID）
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)****