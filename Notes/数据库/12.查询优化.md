## 关联查询优化

建表：

```sql
CREATE TABLE IF NOT EXISTS `class` (
`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card` INT(10) UNSIGNED NOT NULL,
PRIMARY KEY (`id`)
);
CREATE TABLE IF NOT EXISTS `book` (
`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card` INT(10) UNSIGNED NOT NULL,
PRIMARY KEY (`bookid`)
);
 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
```

### left join优化

查看explain

```sql
EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;
```

![image-20200812134203140](assets/image-20200812134203140.png)

如何优化？在哪个表上建立索引？

方案一：在left join右表建索引

```sql
ALTER TABLE `book` ADD INDEX  idx_card( `card`);
```

![image-20200812133937336](assets/image-20200812133937336.png)

方案二：在left join左表建索引

```sql
drop index idx_card on book;
alter table class add index idx_card(card);
```

![image-20200812134120568](assets/image-20200812134120568.png)

结论：

- **在优化关联查询时，只有在被驱动表上建立索引才有效！**
- left join时，左侧的为驱动表，**右侧为被驱动表**！

### inner join

```sql
EXPLAIN SELECT * FROM book inner join class on class.card=book.card;
```

![image-20200812134340091](assets/image-20200812134340091.png)

两个查询字段调换顺序，发现结果也是一样的！

![image-20200812134355262](assets/image-20200812134355262.png)

结论：**inner join 时，mysql会自己帮你把小结果集的表选为驱动表**。

> straight_join: 效果和inner join一样，但是会强制将左侧作为驱动表！
>

### 四个关联查询案例分析

```sql
EXPLAIN SELECT ed.name '人物',c.name '掌门' FROM 
(SELECT e.name,d.ceo from t_emp e LEFT JOIN t_dept d on e.deptid=d.id) ed
 LEFT JOIN t_emp c on ed.ceo= c.id;
```

![image-20200812134624634](assets/image-20200812134624634.png)

```sql
EXPLAIN SELECT e.name '人物',tmp.name '掌门'
FROM t_emp e LEFT JOIN (SELECT d.id did,e.name 
                        FROM t_dept d LEFT JOIN t_emp e ON d.ceo=e.id)tmp 
ON e.deptId=tmp.did;
```

![image-20200812134648225](assets/image-20200812134648225.png)

上述两个案例，第一个查询效率较高，且有优化的余地。第二个案例中，子查询作为被驱动表，由于子查询是虚表，无法建立索引，因此不能优化。

结论：

- **子查询尽量不要放在被驱动表，有可能使用不到索引；**
- left join时，尽量让实体表作为被驱动表。

```sql
EXPLAIN SELECT e1.name '人物',e2.name '掌门' 
FROM t_emp e1 
LEFT JOIN t_dept d on e1.deptid = d.id
LEFT JOIN t_emp e2 on d.ceo = e2.id ;
```

![image-20200812134730191](assets/image-20200812134730191.png)

```sql
Explain SELECT e2.name '人物',
(SELECT e1.name FROM t_emp e1 where e1.id= d.ceo) '掌门'
 from t_emp e2 LEFT JOIN t_dept d on e2.deptid=d.id;
```

![image-20200812134748437](assets/image-20200812134748437.png)

结论：能够直接多表关联的尽量直接关联，不用子查询！

建议：

1) 保证被驱动表的join字段已经被索引
2) Left Join 或者 right join时，选择小表作为驱动表，大表作为被驱动表
3) inner join 时，mysql会自己把小表选为驱动表
4) 子查询尽量不要放在被驱动表，有可能使用不到索引
5) 能直接多表关联就尽量直接关联，不用子查询

## 子查询优化

取所有不为掌门人的员工，按年龄分组！

```sql
select age as '年龄', count(*) as '人数' from t_emp where id  not in 
(select ceo from t_dept where ceo is not null) group by age;
```

![image-20200812134843921](assets/image-20200812134843921.png)

如何优化？

①解决dept表的全表扫描，建立ceo字段的索引：

![image-20200812134856718](assets/image-20200812134856718.png)

此时，再次查询：

![image-20200812134911760](assets/image-20200812134911760.png)

②进一步优化，替换not in。

上述SQL可以替换为：

```sql
select age as '年龄',count(*) as '人数' 
from emp e left join dept d on e.id=d.ceo 
where d.id is null group by age;
```

![image-20200812134943421](assets/image-20200812134943421.png)

结论： 在范围判断时，尽量不要使用not in和not exists，使用 left join on xxx is null代替。

## 排序分组优化

where 条件和 on的判断这些过滤条件，作为优先优化的部门，是要被先考虑的！其次，如果有分组和排序，那么也要考虑group by 和order by。

### 无过滤不索引

```sql
create index idx_age_deptid_name on emp (age,deptid,name);
explain select * from emp where age=40 order by deptid;
explain  select * from emp order by age,deptid;
explain  select * from emp order by age,deptid limit 10;
```

![image-20200812140600799](assets/image-20200812140600799.png)

结论：using filesort说明进行了手工排序！原因在于没有where作为过滤条件。where，limit都相当于一种过滤条件，所以才能使用上索引。

### 顺序错，必排序

```sql
explain  select * from emp where age=45 order by deptid,name;
```

![image-20200812135250088](assets/image-20200812135250088.png)

```sql
explain  select * from emp where age=45 order by  deptid,empno;
```

![image-20200812135312506](assets/image-20200812135312506.png)

empno字段并没有建立索引，因此也无法用到索引，此字段需要排序！

```sql
explain  select * from emp where age=45 order by  name,deptid;
```

![image-20200812135338875](assets/image-20200812135338875.png)

where 两侧列的顺序可以变换，效果相同，但是order by列的顺序不能随便变换!

```sql
explain select * from emp where deptid=45 order by age;
```

![image-20200812135407416](assets/image-20200812135407416.png)

deptid作为过滤条件的字段，无法使用索引，因此排序没法用上索引

### 方向反，必排序

```sql
explain select * from emp where age=45 order by  deptid desc, name desc ;
```

![image-20200812135433265](assets/image-20200812135433265.png)

如果可以用上索引的字段都使用正序或者逆序，实际上是没有任何影响的，无非将结果集调换顺序。

```sql
explain select * from emp where age=45 order by  deptid asc, name desc ;
```

![image-20200812135455698](assets/image-20200812135455698.png)

如果排序的字段，顺序有差异，就需要将差异的部分，进行一次倒置顺序，因此还是需要手动排序的！

### 索引的选择

①首先，清除emp上面的所有索引，只保留主键索引！

```sql
drop index idx_age_deptid_name on emp;
```

②查询：年龄为30岁的，且员工编号小于101000的用户，按用户名称排序

```sql
explain SELECT SQL_NO_CACHE * FROM emp WHERE age =30 AND empno <101000 ORDER BY NAME ;
```

![image-20200812135545979](assets/image-20200812135545979.png)

③全表扫描肯定是不被允许的，因此我们要考虑优化。

思路：首先需要让where的过滤条件，用上索引；

查询中，age.empno是查询的过滤条件，而name则是排序的字段，因此我们来创建一个此三个字段的复合索引：

```sql
create index idx_age_empno_name on emp(age,empno,name);
```

![image-20200812135605354](assets/image-20200812135605354.png)

再次查询，发现using filesort依然存在。

原因： empno是范围查询，因此导致了索引失效，所以name字段无法使用索引排序。

所以，三个字段的符合索引，没有意义，因为empno和name字段只能选择其一！

④解决： 要么选择empno,要么选择name

```sql
drop index idx_age_empno_name on emp;
create index idx_age_name on emp(age,name);
create index idx_age_empno on emp(age,empno);
```

两个索引同时存在，mysql会选择哪个？

![image-20200812135642139](assets/image-20200812135642139.png)

```sql
explain SELECT SQL_NO_CACHE *  
FROM emp use index(idx_age_name) 
WHERE age =30 AND empno <101000 ORDER BY NAME ;
```

![image-20200812135707509](assets/image-20200812135707509.png)

原因：所有的排序都是在条件过滤之后才执行的，所以如果条件过滤了大部分数据的话，几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序但实际提升性能很有限。 相对的 empno<101000 这个条件如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，使用empno字段的范围查询，过滤性更好（empno从100000开始）！

结论： 当范围条件和group by 或者 order by 的字段出现二选一时 ，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。

### 使用覆盖索引

覆盖索引：SQL只需要通过索引树就可以查询所需要的数据，而不必通过查到主键之后回表查询数据。

![image-20200812135737415](assets/image-20200812135737415.png)

### group by

group by 使用索引的原则几乎跟order by一致 ，唯一区别是groupby 即使没有过滤条件用到索引，也可以直接使2用索引。

![image-20200812135755625](assets/image-20200812135755625.png)