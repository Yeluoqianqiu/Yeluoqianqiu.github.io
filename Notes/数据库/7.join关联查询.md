![image-20200810224024835](assets/image-20200810224024835.png)

关联查询有以下几种情况：

- 内连接：inner join(cross join)
- 外连接：左外连接(left [outer] join)、右外连接(right [outer] join)、全外连接(full [outer] join)
- 自连接：同一张表通过取别名，虚拟成两张表

> 注：
>
> 1.连接N张表，至少需要N-1个连接条件
>
> 2.若两个关联表存在相同名字的列，在使用时需要加表名前缀来区分
>

### 关联条件的形式

- where：适用于所有关联查询
- on：与 join连用，on后只能写关联条件，其他约束条件放在where中
- using(列名)：与join连用，要求该列名在两个表中名称一样，且仅用于表示在两表中该关联字段值相等
  ```mysql
    #把关联条件写在where后面
    SELECT ename,dname FROM t_employee,t_department 
    WHERE t_employee.dept_id=t_department.did;

    #把关联条件写在on后面，只能和JOIN一起使用
    SELECT ename,dname FROM t_employee INNER JOIN t_department 
    ON t_employee.dept_id=t_department.did;

    #把关联字段写在using()中，只能和JOIN一起使用
    #两个表中的关联字段必须名称相同，而且只能表示=
    SELECT ename,basic_salary FROM t_employee INNER JOIN t_salary USING(eid);
  ```

### 笛卡尔积

定义：将两（或多）个表的所有行进行组合，连接后的行数为两（或多）个表的乘积数.

```mysql
#查询员工姓名和所在部门名称
SELECT ename,dname FROM t_employee,t_department;
SELECT ename,dname FROM t_employee JOIN t_department;
```

内连接若缺少关联条件，查询结果也为笛卡尔积：

```mysql
SELECT ename,dname FROM t_employee INNER JOIN t_department;
SELECT ename,dname FROM t_employee CROSS JOIN t_department;
```

## 关联查询的具体情况

以如下两表为例：

![image-20200309165011757](assets/image-20200309165011757.png)

### 内连接 A∩B

返回连接表中符合连接条件和查询条件的数据行

> 如果不写关联条件，会导致笛卡尔积
>

形式一：

```mysql
select 列名1, 列名2, ...
from A表 inner join B表
on 关联条件 where [其他筛选条件]
```

形式二：

```mysql
select 列名1, 列名2, ...
from A表, B表
where 关联条件
```

示例：

```mysql
# 查询员工姓名、编号和所在部门名称，部门编号
select emp_name,emp_id,dep_name,department.dep_id from department,employees 
where department.dep_id = employees.dep_id;
+----------+--------+----------+--------+
| emp_name | emp_id | dep_name | dep_id |
+----------+--------+----------+--------+
| 张三     |   1001 | 教学部   |      1 |
| 李四     |   1002 | 教学部   |      1 |
| 王五     |   1003 | 咨询部   |      2 |
+----------+--------+----------+--------+
```

### 左外连接

对于连接条件的属性列，返回左表中的所有行，如果左表中的行在右边没有出现，右表对应列补NULL。

```mysql
select 列名1, 列名2, ...
from A表 left join B表
on 关联条件
```

示例：

```mysql
#查询所有部门信息以及该部门员工信息
select department.dep_id,dep_name,emp_id,emp_name
from department left join employees
using(dep_id);
+--------+----------+--------+----------+
| dep_id | dep_name | emp_id | emp_name |
+--------+----------+--------+----------+
|      1 | 教学部   |   1001 | 张三     |
|      1 | 教学部   |   1002 | 李四     |
|      2 | 咨询部   |   1003 | 王五     |
|      3 | 就业部   |   NULL | NULL     |
+--------+----------+--------+----------+
```

#### A - A∩B

对于连接条件的属性列，返回只存在于左表中的记录，右表相应位置补NULL

```mysql
select 列名1, 列名2, ...
from A表 left join B表
on 关联条件
where A表关联字段在B表没有对应
```

示例：

```mysql
# 查询没有员工的部门的信息
select department.dep_id,dep_name,emp_id,emp_name
from department left join employees
on department.dep_id = employees.dep_id
where employees.dep_id is null;
+--------+----------+--------+----------+
| dep_id | dep_name | emp_id | emp_name |
+--------+----------+--------+----------+
|      3 | 就业部   |   NULL | NULL     |
+--------+----------+--------+----------+
```

### 右外连接

### 全连接 FULL JOIN

MySQL不支持FULL JOIN，而是使用LEFT JOIN **UNION** RIGHT JOIN

### A∪B

```mysql
select 列名1，列名2，...
from A表 left join B表
on 关联条件
union
select 列名1，列名2，...
from A表 right join B表
on 关联条件
```

示例：

```mysql
# 查询所有部门信息和所有员工信息
select department.dep_id,dep_name,emp_id,emp_name
from department left join employees
on department.dep_id = employees.dep_id
union
select department.dep_id,dep_name,emp_id,emp_name
from department right join employees
on department.dep_id =  employees.dep_id;
+--------+----------+--------+----------+
| dep_id | dep_name | emp_id | emp_name |
+--------+----------+--------+----------+
|      1 | 教学部   |   1001 | 张三     |
|      1 | 教学部   |   1002 | 李四     |
|      2 | 咨询部   |   1003 | 王五     |
|      3 | 就业部   |   NULL | NULL     |
|   NULL | NULL     |   1004 | 赵六     |
+--------+----------+--------+----------+
```

### A∪B -  A∩B

```mysql
select 列名1，列名2，...
from A表 left join B表
on 从表关联字段在主表没有对应
union
select 列名1，列名2，...
from A表 right join B表
on 从表关联字段在主表没有对应
```

示例：

```mysql
# 查询所有没有员工的部门和没有分配部门的员工
select department.dep_id,dep_name,emp_id,emp_name
from department left join employees
on department.dep_id = employees.dep_id
where employees.dep_id is null
union
select department.dep_id,dep_name,emp_id,emp_name
from department right join employees
on department.dep_id =  employees.dep_id
where employees.dep_id is null;
+--------+----------+--------+----------+
| dep_id | dep_name | emp_id | emp_name |
+--------+----------+--------+----------+
|      3 | 就业部   |   NULL | NULL     |
|   NULL | NULL     |   1004 | 赵六     |
+--------+----------+--------+----------+
# null项一定以从表为准
```