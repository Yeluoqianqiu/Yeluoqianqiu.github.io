## explain简介

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。

官网地址：https://dev.mysql.com/doc/refman/5.7/en/explain-output.html

**本文以下测试使用mysql 5.6.24，后续版本对查询进行了优化，测试结果很可能不同。**

使用：Explain+SQL语句

```shell
mysql> explain select * from t1;
+--+-----------+-----+----+-------------+----+-------+----+----+-----+
|id|select_type|table|type|possible_keys| key|key_len| ref|rows|Extra|
+--+-----------+-----+----+-------------+----+-------+----+----+-----+
| 1| SIMPLE    | t1  | ALL| NULL        |NULL| NULL  |NULL|  1 |NULL |
+--+-----------+-----+----+-------------+----+-------+----+----+-----+
```

字段解释：

id:  select 查询的序列号，表示查询中执行select子句或操作表的顺序。

select_type: 主要用于区别普通查询、联合查询、子查询等的复杂查询。

table: 这个数据是基于哪张表的。

partitions: 查询数据匹配的分区

**type: 是查询的访问类型，是较为重要的一个指标**

possible_keys: 显示可能应用在这张表中的索引，一个或多个。

key: 实际使用的索引。如果为NULL，则没有使用索引。

key_len: 表示索引中使用的字节数

ref: 显示索引的哪一列被使用了

rows: 显示MySQL认为它执行查询时必须检查的行数，不精确。

filtered: 返回结果的行占需要读到的行(rows列的值)的百分比

Extra: 其他的额外重要的信息。

## 准备数据

### 建表

```sql
CREATE TABLE `dept` (
 `id` INT(11) NOT NULL AUTO_INCREMENT,
 `deptName` VARCHAR(30) DEFAULT NULL,
 `address` VARCHAR(40) DEFAULT NULL,
  ceo INT NULL ,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `emp` (
 `id` INT(11) NOT NULL AUTO_INCREMENT,
 `empno` INT NOT NULL ,
 `name` VARCHAR(20) DEFAULT NULL,
 `age` INT(3) DEFAULT NULL,
 `deptId` INT(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
 #CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

开启 log_bin_trust_function_creators，它控制是否可以信任存储函数创建者

```sql
mysql> show variables like 'log_bin_trust_function_creators'; //查询
mysql> set global log_bin_trust_function_creators=1;  //开启
```

若需设置永久生效方式：修改/etc/my.cnf 文件

```shell
[mysqld]
log_bin_trust_function_creators=1
```

### 编写随机函数

1）生成随机字符串

```sql
DELIMITER $$
CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
BEGIN    
DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
 DECLARE return_str VARCHAR(255) DEFAULT '';
 DECLARE i INT DEFAULT 0;
 WHILE i < n DO  
 SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));  
 SET i = i + 1;
 END WHILE;
 RETURN return_str;
END $$
```

2）如果要删除函数，则执行：drop function rand_string

3）生成随机部门编号

```sql
--用于随机产生多少到多少的编号
DELIMITER $$
CREATE FUNCTION  rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN   
 DECLARE i INT DEFAULT 0;  
 SET i = FLOOR(from_num +RAND()*(to_num -from_num+1))   ;
RETURN i;  
END$$
```

4）如果要删除函数：drop function rand_num

### 创建存储过程

1）创建往emp表中插入数据的存储过程

```sql
DELIMITER $$
CREATE PROCEDURE  insert_emp(  START INT ,  max_num INT )
BEGIN  
DECLARE i INT DEFAULT 0;   
--set autocommit =0 把autocommit设置成0  
 SET autocommit = 0;    
 REPEAT  
 SET i = i + 1;  
 INSERT INTO emp (empno, NAME ,age ,deptid ) VALUES ((START+i) ,rand_string(6)   , rand_num(30,50),rand_num(1,10000));  
 UNTIL i = max_num  
 END REPEAT;  
 COMMIT;  
 END$$ 
 
--删除
-- DELIMITER ;
-- drop PROCEDURE insert_emp;
```

2）创建往dept表中插入数据的存储过程

```sql
--执行存储过程，往dept表添加随机数据
DELIMITER $$
CREATE PROCEDURE `insert_dept`(  max_num INT )
BEGIN  
DECLARE i INT DEFAULT 0;   
 SET autocommit = 0;    
 REPEAT  
 SET i = i + 1;  
 INSERT INTO dept ( deptname,address,ceo ) VALUES (rand_string(8),rand_string(10),rand_num(1,500000));  
 UNTIL i = max_num  
 END REPEAT;  
 COMMIT;  
 END$$
 
--删除
-- DELIMITER ;
-- drop PROCEDURE insert_dept;
```

### 调用随机过程

1）添加数据到部门表

```sql
--执行存储过程，往dept表添加1万条数据
DELIMITER ;
CALL insert_dept(10000);
```

2）添加数据到员工表

```sql
--执行存储过程，往emp表添加50万条数据
DELIMITER ;
CALL insert_emp(100000,500000);
```

### 批量删除某个表上的所有索引

1）删除索引的存储过程

```sql
DELIMITER $$
CREATE  PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))
BEGIN
       DECLARE done INT DEFAULT 0;
       DECLARE ct INT DEFAULT 0;
       DECLARE _index VARCHAR(200) DEFAULT '';
       DECLARE _cur CURSOR FOR  SELECT   index_name   FROM information_schema.STATISTICS   WHERE table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND    index_name <>'PRIMARY'  ;
       DECLARE  CONTINUE HANDLER FOR NOT FOUND set done=2 ;      
        OPEN _cur;
        FETCH   _cur INTO _index;
        WHILE  _index<>'' DO 
               SET @str = CONCAT("drop index ",_index," on ",tablename ); 
               PREPARE sql_str FROM @str ;
               EXECUTE  sql_str;
               DEALLOCATE PREPARE sql_str;
               SET _index=''; 
               FETCH   _cur INTO _index; 
        END WHILE;
CLOSE _cur;
END$$
```

2）执行存储过程

```sql
CALL proc_drop_index("dbname","tablename");
```

## explain字段分析

创建测试数据：

```sql
CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content  VARCHAR(100) NULL ,  PRIMARY KEY (id));
CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content  VARCHAR(100) NULL ,  PRIMARY KEY (id));
CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content  VARCHAR(100) NULL ,  PRIMARY KEY (id));
CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content  VARCHAR(100) NULL ,  PRIMARY KEY (id));

INSERT INTO t1(content) VALUES(CONCAT('t1_',FLOOR(1+RAND()*1000)));
INSERT INTO t2(content) VALUES(CONCAT('t2_',FLOOR(1+RAND()*1000)));
INSERT INTO t3(content) VALUES(CONCAT('t3_',FLOOR(1+RAND()*1000)));
INSERT INTO t4(content) VALUES(CONCAT('t4_',FLOOR(1+RAND()*1000)));
```

### id(了解)

id: select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序

1) id相同：执行顺序由上至下

```sql
mysql>EXPLAIN select * from t1,t2,t3 where t1.id = t2.id and t2.id = t3.id ;
+--+-----------+-----+------+-------------+-------+-------+----------+----+-----+
|id|select_type|table|type  |possible_keys|key    |key_len|ref       |rows|Extra|
+--+-----------+-----+------+-------------+-------+-------+----------+----+-----+
| 1| SIMPLE    | t1  | ALL  | PRIMARY     | NULL  | NULL  | NULL     |  1 | NULL|
| 1| SIMPLE    | t2  |eq_ref| PRIMARY     |PRIMARY| 4     |test.t1.id|  1 | NULL|
| 1| SIMPLE    | t3  |eq_ref| PRIMARY     |PRIMARY| 4     |test.t1.id|  1 | NULL|
+--+-----------+-----+------+-------------+-------+-------+----------+----+-----+
```

2)id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

```sql
mysql> EXPLAIN select t1.id from t1 where t1.id in
(select t2.id from t2 where t2.id in 
 (select t3.id from t3 where t3.content = ''));
--mysql 5.6及以后已经优化了，带子查询的仍然是一趟执行完成：
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra       |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+
|  1 | SIMPLE      | t1    | index  | PRIMARY       | PRIMARY | 4       | NULL       |    1 | Using index |
|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 | Using index |
|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 | Using where |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+
```

mysql 5.5的结果：

![image-20200811152052803](assets/image-20200811152052803.png)

3)有相同也有不同

```sql
mysql> EXPLAIN select t2.* from t2 ,(select * from t3 where t3.content = '') s3 where 
        s3.id = t2.id ;
        
+----+-------------+------------+------+---------------+-------------+---------+------------+------+-------------+
| id | select_type | table      | type | possible_keys | key         | key_len | ref        | rows | Extra       |
+----+-------------+------------+------+---------------+-------------+---------+------------+------+-------------+
|  1 | PRIMARY     | t2         | ALL  | PRIMARY       | NULL        | NULL    | NULL       |    1 | NULL        |
|  1 | PRIMARY     | <derived2> | ref  | <auto_key0>   | <auto_key0> | 4       | test.t2.id |    2 | NULL        |
|  2 | DERIVED     | t3         | ALL  | NULL          | NULL        | NULL    | NULL       |    1 | Using where |
+----+-------------+------------+------+---------------+-------------+---------+------------+------+-------------+
```

4)总结：

id如果相同，可以认为是一组，从上往下顺序执行；

在所有组中，id值越大，优先级越高，越先执行 。

id号每个号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。

### select_type(了解)

select_type : 主要用于区别普通查询、联合查询、子查询等的复杂查询。

| 属性                 | 含义                                                                                                            |
| -------------------- | --------------------------------------------------------------------------------------------------------------- |
| SIMPLE               | 简单的 select 查询,查询中不包含子查询或者UNION                                                                  |
| PRIMARY              | 查询中若包含任何复杂的子部分，最外层查询则被标记为Primary                                                       |
| DERIVED              | 在FROM列表中包含的子查询被标记为DERIVED(衍生)  MySQL会递归执行这些子查询, 把结果放在临时表里。                  |
| SUBQUERY             | 在SELECT或WHERE列表中包含了子查询                                                                               |
| DEPEDENT SUBQUERY    | 在SELECT或WHERE列表中包含了子查询,子查询基于外层                                                                |
| UNCACHEABLE SUBQUERY | 无法使用缓存的子查询                                                                                            |
| UNION                | 若第二个SELECT出现在UNION之后，则被标记为UNION；  若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED |
| UNION RESULT         | 从UNION表获取结果的SELECT                                                                                       |

### type(重点)

type是查询的访问类型，是较为重要的一个指标结果值从最好到最坏依次是：

system > const > **eq_ref** > **ref** > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > **range** > index > **ALL**

【只需要关注加粗的几个】

**一般来说，得保证查询至少达到range级别，最好能达到ref。**

1)system

表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。

2)const

表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。

```sql
mysql> EXPLAIN  select * from t1 where t1.id  = 1;
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | t1    | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
```

3)eq_ref

唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。

```sql
mysql> EXPLAIN select * from t1 ,t2 where t1.id = t2.id ;
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
|  1 | SIMPLE      | t1    | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    1 | NULL  |
|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 | NULL  |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+                       
```

4)ref

非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该**属于查找和扫描的混合体**。

没用索引前：

```sql
mysql> EXPLAIN select * from t1 ,t2 where t1.content = t2.content;
+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                              |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL                                               |
|  1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
```

建立索引后：

```sql
mysql> create index idx_t2_content on t2(content);
mysql> EXPLAIN select * from t1 ,t2 where t1.content = t2.content;
+----+-------------+-------+------+----------------+----------------+---------+-----------------+------+-------------+
| id | select_type | table | type | possible_keys  | key            | key_len | ref             | rows | Extra       |
+----+-------------+-------+------+----------------+----------------+---------+-----------------+------+-------------+
|  1 | SIMPLE      | t1    | ALL  | NULL           | NULL           | NULL    | NULL            |    1 | Using where |
|  1 | SIMPLE      | t2    | ref  | idx_t2_content | idx_t2_content | 103     | test.t1.content |    1 | Using index |
+----+-------------+-------+------+----------------+----------------+---------+-----------------+------+-------------+
```

5) range

只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、<、>、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。

```sql
mysql> EXPLAIN select * from t1 where t1.id >10 ;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |    1 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
```

```sql
mysql> EXPLAIN select * from t1 where t1.id between 1 and 3 ;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |    1 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
```

```sql
mysql> EXPLAIN select * from t1 where t1.id in (1,2);
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
```

6)index

索引全表扫描，虽然使用了索引但是并没有起到过滤的作用，这个时候会遍历整个索引树

```sql
mysql> EXPLAIN select * from t1;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
```

```sql
mysql> EXPLAIN select id from t1;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t1    | index | NULL          | PRIMARY | 4       | NULL |    1 | Using index |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
```

7)all

Full Table Scan，将遍历全表以找匹配的行。

```sql
--当content字段不是索引时
mysql> EXPLAIN select * from t1 ,t2 where t1.content = t2.content;
+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                              |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL                                               |
|  1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
```

8)index_merge

在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中。

MySQL5.5的结果:

![image-20200811162002112](assets/image-20200811162002112.png)

9)ref_or_null

对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。

```sql
mysql> EXPLAIN select * from t2 where t2.content is null or t2.content = 'abc';
+----+-------------+-------+-------------+----------------+----------------+---------+-------+------+--------------------------+
| id | select_type | table | type        | possible_keys  | key            | key_len | ref   | rows | Extra                    |
+----+-------------+-------+-------------+----------------+----------------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | t2    | ref_or_null | idx_t2_content | idx_t2_content | 103     | const |    2 | Using where; Using index |
+----+-------------+-------+-------------+----------------+----------------+---------+-------+------+--------------------------+
```

10)index_subquery

利用索引来关联子查询，不再全表扫描。

```sql
mysql> create index idx_t3_content on t3(content);
mysql> EXPLAIN select * from t2 where t2.content in (select t3.content from t3) ;
+----+-------------+-------+-------+----------------+----------------+---------+-----------------+------+-----------------------------+
| id | select_type | table | type  | possible_keys  | key            | key_len | ref             | rows | Extra                       |
+----+-------------+-------+-------+----------------+----------------+---------+-----------------+------+-----------------------------+
|  1 | SIMPLE      | t2    | index | idx_t2_content | idx_t2_content | 103     | NULL            |    1 | Using where; Using index    |
|  1 | SIMPLE      | t3    | ref   | idx_t3_content | idx_t3_content | 103     | test.t2.content |    1 | Using index; FirstMatch(t2) |
+----+-------------+-------+-------+----------------+----------------+---------+-----------------+------+-----------------------------+
```

MySQL5.5的结果:

![image-20200811162143363](assets/image-20200811162143363.png)

11)unique_subquery

该联接类型类似于index_subquery。 子查询中的唯一索引。

```sql
mysql> EXPLAIN select * from t2 where t2.id in (select t3.id from t3 );
+----+-------------+-------+--------+---------------+----------------+---------+------------+------+-------------+
| id | select_type | table | type   | possible_keys | key            | key_len | ref        | rows | Extra       |
+----+-------------+-------+--------+---------------+----------------+---------+------------+------+-------------+
|  1 | SIMPLE      | t2    | index  | PRIMARY       | idx_t2_content | 103     | NULL       |    1 | Using index |
|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY        | 4       | test.t2.id |    1 | Using index |
+----+-------------+-------+--------+---------------+----------------+---------+------------+------+-------------+
```

MySQL5.5的结果

![image-20200811162234269](assets/image-20200811162234269.png)

### possible_keys(重点)

显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，**但不一定被查询实际使用。**

### key

实际使用的索引。如果为NULL，则没有使用索引。

### key_len

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len字段能够帮你检查是否充分的利用上了索引。**ken_len越长，说明索引使用的越充分。**

示例如下

![image-20200811163948371](assets/image-20200811163948371.png)

![image-20200811163956341](assets/image-20200811163956341.png)

**如何计算：**

1） 先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20

2） 如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8 要乘 3,GBK要乘2

3） varchar这种动态字符串要加2个字节

4） 允许为空的字段要加1个字节

第一组：key_len=age的字节长度：name的字节长度=4+1 + ( 20*3+2)=5+62=67

第二组：key_len=age的字节长度：4+1=5

![image-20200811164027238](assets/image-20200811164027238.png)

### ref

显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。

```sql
mysql> create index idx_name_t_emp on t_emp(name);
mysql> EXPLAIN select * from t_emp emp ,t_dept dept  where emp.name = 'aaa' 
and emp.deptId = dept.id ;
```

![image-20200811164127433](assets/image-20200811164127433.png)

### rows

rows列显示MySQL认为它执行查询时必须检查的行数。**越少越好**

```sql
mysql> create index idx_name_t_emp on t_emp(name);
mysql> EXPLAIN select * from t_emp emp ,t_dept dept  where emp.name = 'aaa' 
and emp.deptId = dept.id ;
```

![image-20200811164205205](assets/image-20200811164205205.png)

### Extra(重要)

**1)Using filesort(重要)**

在使用order by关键字的时候，如果待排序的字段不是索引字段，那么mysql有可能进行文件排序。

filesort是通过相应的排序算法，将取得的数据在内存中进行排序。using filesort不一定引起mysql的性能问题。但是如果查询次数非常多，那么每次在mysql中进行排序，还是会有影响的。
此时，可以进行的优化：
1、修改逻辑，不在mysql中使用order by而是在应用中自己进行排序。
2、使用mysql索引，将待排序的内容放到索引中，直接利用索引的排序。

优化前：

```sql
mysql> explain select id ,empno ,name  from t_emp 
where deptid = 100 order by name limit 10 ;
```

![image-20200811164312426](assets/image-20200811164312426.png)

优化后：

```sql
mysql> create index idx_name_emp_1 on emp(name);
mysql> explain select id ,empno ,name from emp 
where deptId = 100  order by name limit 10 ;
```

![image-20200811164337453](assets/image-20200811164337453.png)

2)Using temporary

使用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。

优化前：

```sql
mysql> explain select  name, count(*) from emp where deptid = 100 group by name limit 10 ;
```

![image-20200811164424397](assets/image-20200811164424397.png)

优化后：

```sql
mysql> create index idx_name_emp_1 on emp(name);
mysql> explain select  name, count(*) from emp where deptid = 100 group by name limit 10 ;
```

![image-20200811164449082](assets/image-20200811164449082.png)

3)Using index

Using index表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！

如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。

```sql
mysql> explain select id from emp where id >1000 order by  id ;
```

![image-20200811164526787](assets/image-20200811164526787.png)

4)Using where

不用读取表里面的所有信息，只需要通过索引就可以拿到需要的数据，这个过程发生在对表的全部请求列都是同一个索引部分时。

5)Using join buffer：使用了连接缓存。

```sql
mysql> explain select * from emp ,dept where emp.empno = dept.ceo ;
```

![image-20200811164607720](assets/image-20200811164607720.png)

6)impossible where：【5.7后没有了】

where子句的值总是false，不能用来获取任何元组。

```sql
mysql> explain select empno, name from emp where empno >200000 and empno < 100000;
```

![image-20200811164640276](assets/image-20200811164640276.png)

MySQL5.5的结果:

![image-20200811164655154](assets/image-20200811164655154.png)

7)select tables optimized away

在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询Explain生成的阶段即完成优化。

在InnoDB中：

```sql
mysql> explain select max(id) from emp ;
```

![image-20200811164746968](assets/image-20200811164746968.png)

在MyISAM中：

![image-20200811164810390](assets/image-20200811164810390.png)