Java Database Connectivity：Java数据库连接

JDBC代表一组API，一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口(一组API)

JDBC设计了一组公共的接数据库的代码，应该用哪些类型，哪些方法。

这些操作数据库底层的具体的代码由数据库厂商来实现，这些实现类，就称为"数据库驱动"。

即你要连接和操作mysql就用mysql的驱动，要连接oracle就用oracle的驱动。

Java代码就通过接口+驱动+标准的sql语句实现了Java代码与各个数据库的连接和操作。

## JDBC程序的开发步骤

1. 将驱动jar包引入到项目中 在项目中创建libs文件夹，拖入jar包，在IDEA中对jar包右键，选择add as alibrary.
2. 编写代码
      用到的API：
   ```java
      //java.sql.DriverManager:驱动管理类
          Connection conn = DriverManager.getConnection(url,username,password);
      //java.sql.Connection:
      	Statement st = conn.createStatement();
      //java.sql.Statement:
      	int len = st.executeUpdate(sql);//len是受影响的行数
      	ResultSet rs = st.executeQuery(sql);//查询结果集
      //java.sql.ResultSet:
      	boolean hasNext = rs.next():判断是否还有下一个;
      	xxx xxx = Xxx rs.getXxx(字段名/序号);
   ```

```java
//1.注册驱动：将驱动类加载到内存中
Class.forName("com.mysql.cj.jdbc.Driver");
//mysql5  com.mysql.jdbc.Driver

//2.获取连接：即登录数据库
String mysqlUrl = "jdbc:mysql://localhost/table_name?useSSL=FALSE&serverTimezone=UTC"
//mysql5  String mysqlUrl = "jdbc:mysql://主机地址:端口号/数据库名";
//oracle  String oracleUrl = "jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名";
//sqlserver  String sqlServerUrl = "jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称";
String username = "用户名";
String password = "密码";

Connection conn = DriverManager.getConnection(mysqlUrl,username,password);

//3.编写sql语句：
String sql = "...";

//4.创建Statement对象，并执行sql语句，接收结果
Statement st = conn.createStatement();

//(1) 更新：添加、修改、删除  executeUpdate()
int len = st.executeUpdate(sql);
//(2) 查询 executeQuery()
ResultSet rs = st.executeQuery(sql);
while(rs.next()){
    xxx xxx = rs.getXxx(字段名/序号);//序号从1开始
}

//5.关闭re、st和conn
re.close();
st.close();
conn.close();
```

## PreparedStatement

### Statement存在以下三个问题

- SQL拼接：插入很多数据时，sql字符串要拼接多次，不方便输入。
  ```java
    Scanner input = new Scanner(System.in);
    System.out.println("请输入姓名：");
    String name = input.nextLine();

    System.out.println("请输入领导编号：");
    int mid = input.nextInt();

    System.out.println("请输入部门编号：");
    int did = input.nextInt();

    String sql = "INSERT INTO emp (ename,`mid`,did) VALUES('" + name+"'," + mid + "," + did + ")";
  ```
- SQL注入：系统对用户输入的数据没有进行充分的检查，用户可以通过输入精心构造的字符串取非法获取数据库中的数据。
  ```java
    Scanner input = new Scanner(System.in);
    System.out.println("请输入姓名：");
    String name = input.nextLine();

    String sql = "SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = '" + name + "'";
    //当用户输入  小明' or '1'='1
    //sql语句为： select eid,ename,tel,gender,salary from t_employee where ename = '小明' or '1' = '1'; 
    //本来只允许查询ename = '小明'的信息，但由于'1' = '1'恒成立，会查到所有人的信息。
  ```
- 无法处理Blob类型的数据：Blob(Binary large object, 二进制大对象) 用于在数据库中存储二进制文件。二进制文件不能通过字符串拼接的形式，正确传给sql服务器。

四种blob类型：

![](assets/image-20200314141941327.png)

如果使用了blob数据类型仍然报错，需要在mysql安装目录下将my.ini文件加上如下参数：max_allowed_package=16M，并重启mysql服务。

### PreparedStatement与Statement的比较

PreparedStatement是Statement的子类。

PreparedStatement方便了sql字符串的拼接，且在尝试sql注入会导致无响应，并且可以传入Blob数据类型的数据了，提高了代码的可读性和可维护性。

另外：PreparedStatement能最大可能提高性能：Oracle和PostgreSQL8显著，MySQL不一定有效。

### PreparedStatement执行sql语句的步骤

```java
//1.准备sql语句，?作为占位符
String sql = "insert into t1 values(1,?,?)";
//2.获取PreparedStatement对象：传入sql语句进行预编译
PreparedStatement pst = conn.preparedStatement(sql);
//3.填充?的具体内容  索引从1开始
pst.setObject(1,...);
pst.setObject(2,...);
//4.执行sql语句
ResultSet rs = pst.executeQuery();//用于查询
//int len = pst.executeUpdate();//用于增删改
```

示例：使用PreparedStatement插入Blob数据：

```java
@Test
public void addBlob() throws Exception {
	Scanner input = new Scanner(System.in);
    System.out.println("请输入用户名：");
    String username = input.nextLine();

    System.out.println("请输入密码：");
    String pwd = input.nextLine();

    System.out.println("请指定照片的路径：");
    String photoPath = input.nextLine();

    //1、连接数据库
    Class.forName("com.mysql.jdbc.Driver");
    String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";
    Connection conn = DriverManager.getConnection(url, "root", "123456");

    //2、 INSERT INTO t1 VALUES(NULL,用户名,密码,照片)
    String sql = "INSERT INTO t1 (username,passwd,head_picture)VALUES(?,?,?)";

    // 3、准备一个PreparedStatement：预编译sql
    PreparedStatement pst = conn.prepareStatement(sql);// 对带？的sql进行预编译

    // 4、对？进行设置
    pst.setString(1, username);
    pst.setString(2, pwd);
    pst.setBlob(3, new FileInputStream(photoPath));

    // 5、执行sql
    int len = pst.executeUpdate();
    System.out.println(len > 0 ? "添加成功" : "添加失败");

    // 6、释放资源
    pst.close();
    conn.close();
	}
}
```

### JDBC取得数据库自动生成的主键

改动：

```java
PreparedStatement pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEY);
//默认是Statement.NO_GENERATED_KEYS  是Statement类的静态常量

int len = pst.executeUpdate();
ResultSet rs = pst.getGeneratedKeys();
if(rs.next()){
    Object key = rs.getObject(1);
}
```

### 批处理

用于将多个sql语句分批次交付，节省了每次都要与sql服务器对话的时间。

场景：

- 多条SQL语句的批量处理；
- 一条SQL语句的批量传参。

步骤：

- 在url中添加参数`rewriteBatchedStatements=true`
- 实现一个循环，每次将要执行的sql语句添加到缓存：`pst.addBatch();`
- 在循环体外执行批处理语句：`pst.executeBatch();`

> 若将insert into t1 values(...) 的values写成value，可以执行，但批处理没有效果。
>

示例：

```java
@Test
public void useBatch()throws Exception{
    Class.forName("com.mysql.jdbc.Driver");

    String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC&rewriteBatchedStatements=true";
    Connection conn = DriverManager.getConnection(url, "root", "123456");

    String sql = "INSERT INTO t_department(dname,description) VALUES(?,?)";
    PreparedStatement st = conn.prepareStatement(sql);

    for(int i=0; i<1000; i++){
        st.setString(1, "测试部门" + i);
        st.setString(2, "测试部门描述"  + i);

        st.addBatch();
    }
    st.executeBatch();

    st.close();
    conn.close();
	}
}
```

### 事务

核心是**同一个事务的多个操作要在同一个conn连接下**，否则无法保证事务的一致性。

JDBC实现事务的步骤：

- 执行sql之前先关闭自动提交事务：`conn.setAutoCommit(false);`
- 将所有sql语句放在try-catch-finally中，若所有sql语句执行成功，则提交事务：`conn.commit();`
- 若其中某个操作失败或出现异常，则回滚事务：`conn.rollback();`
- 关闭conn之前需要恢复其自动提交状态 `conn.setAutoCommit(true);`
- 关闭连接`conn.close();`

示例：

```java
public class TestTransaction {
    public static void main(String[] args) {
        Connection conn = null;
        try {
            //1、连接数据库
            Class.forName("com.mysql.cj.jdbc.Driver");

            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";
            conn = DriverManager.getConnection(url, "root", "950722");
            //设置手动提交
            conn.setAutoCommit(false);

            String sql1 = "update t_department set description = ? where did = ?";
            PreparedStatement pst1 = conn.prepareStatement(sql1);
            pst1.setObject(1, "挣大钱的");
            pst1.setObject(2, 4);
            int len1 = pst1.executeUpdate();
            System.out.println(len1 > 0 ? "更新部门信息成功" : "更新部门信息失败");
            pst1.close();

            String sql2 = "update t_employee set salary = salary + ? where did = ?";
            PreparedStatement pst2 = conn.prepareStatement(sql2);
            pst2.setObject(1, 20000);
            pst2.setObject(2, 4);
            int len2 = pst2.executeUpdate();
            System.out.println(len2 > 0 ? "更新部门信息成功" : "更新部门信息失败");
            pst2.close();

            conn.commit();
        } catch (Exception e) {
            try {
                if (conn != null) {
                    conn.rollback();
                }
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        } finally {
            try {
                if (conn != null) {
                    //恢复自动提交
                    conn.setAutoCommit(true);
                    //释放连接
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 数据库连接池

之前的JDBC编程存在两个问题：

- 问题1：注册驱动，获取连接的操作，需要多次书写，繁琐
- 问题2：每次数据库需求都要重新建立与数据库服务器的连接：
  -   - mysql遵循TCP/IP协议：一次连接的成本很高，连接需要“三次握手”，断开需要“四次挥手”
  -   - 每一个客户端都有单独的线程来维护它的通信：当过多客户端同时连接mysql服务器时，并发量太高很容易导致mysql服务器挂掉【特别是有些连接未及时关闭】

解决：

- 解决问题1：将注册驱动、获取连接等方法封装到一个工具类中，减少代码
- 解决问题2：使用数据库连接池

数据库连接池技术：

1. 创建一个数据库连接池pool，在池中先放一些连接对象，程序取获取连接对象时，优先使用已建好的对象。
2. 设置连接池的最大连接数，若池中所有连接都在使用的话，可以让请求连接的客户端等待，虽然有等待现象，总比服务器挂掉好。
3. 创建连接池时，一开始只初始化少量的连接，等用户并发量增多后，会增加连接数，直到最高连接数为止。
4. 之前执行conn.close()会真正将服务器连接断开，现在是将连接归还到连接池中。

连接池有很多库，我们使用阿里的druid

使用步骤：

1. 引入德鲁伊jar包
2. 在src下加一个配置文件druid.properties：配置德鲁伊连接池的参数：主机名、端口号、用户名、密码、驱动类名、初始化连接数、最大等待时间、...
3. 创建一个连接池：DataSource 导入包：javax.sql.DataSource;
   ```java

   ```
4. 提供一个方法，用于从数据库连接池中拿连接对象