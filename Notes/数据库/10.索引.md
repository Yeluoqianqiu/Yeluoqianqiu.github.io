## B树和B+树

### 1. 数据结构

B Tree 指的是 Balance Tree，又称**多路平衡查找树**，并且所有叶子结点位于同一层。B树的高度代表了磁盘读取的次数。

B+ 树是应数据库所需而出现的一种B树的变种树，在 B+树中，一个结点包含n个关键字和n个指针，关键字从左到右升序排列，如果某个指针的左右相邻关键字分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向结点的所有 key 大于等于 key<sub>i</sub> 且小于 key<sub>i+1</sub>。

B树：

![image-20200810230215729](assets/image-20200810230215729.png)

B+树：

![image-20200810230618978](assets/image-20200810230618978.png)

### 2. B+树与B树的区别

- B树的结点存储了关键字、指针和数据记录；**B+树的非叶子节点中只有关键字和指针，全部数据记录保存在叶结点。**
- B树中，越靠近根节点的记录查找速度越快；而B+树中每次查找，无论成功与否，**都是一条从根结点到叶结点的路径**。看起来B树的查找性能更好，但由于**B+树的非叶结点不存放实际数据，这样每个结点可容纳的关键字个数比B树多得多，同样量级的数据，B+树的高度比B树低，节省了磁盘读取的时间。**
- B+树中，前一个叶结点含有**指向下一个叶结点的指针**，**方便区间查询**。

其他：

- B树的每个关键字只出现一次，B+树采用**冗余索引**，关键字在查询的路径上多次出现，用于划分区间，**叶结点中包含了全部关键字**。
- **B+树有两个头指针**：一个指向根结点，用于多路查找；一个指向关键字最小的叶结点，用于顺序查找。

### 3. 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的data。

**插入删除操作会破坏平衡树的平衡性**，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

### 4. 与红黑树的比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要原因：

平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

## 索引的概念

索引是数据库中用于**加速查找**的一种数据结构。相当于字典的目录。根据索引获取数据的存放地址，再到该地址获取数据即可。

索引的优缺点：

- 索引加快了查询速度，降低了数据库的IO成本。
- 但**降低了增删改的速度**，因为更新表时，不仅要更新数据文件，还要对相应的索引文件进行更新。对索引文件的保存需要占用额外存储空间。

索引是在引擎层实现的，而不是在服务器层实现的，所以不同引擎具有不同的索引类型和实现。

### 1. B+Tree 索引

是大多数 MySQL 存储引擎的默认索引类型。

因为**不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多**。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为**聚簇索引**。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

辅助索引的叶子节点的 data域记录着**主键的值**，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

### 2. 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 3. 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

### 4. 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

## 索引的创建

| 创建索引 | create [unique] index [index_name] on  table_name(column);                                                  |
| -------- | ----------------------------------------------------------------------------------------------------------- |
| 删除索引 | 删除非主键索引：drop  index index_name on table_name;  删除主键索引：ALTER TABLE customer drop PRIMARY KEY; |
| 查看索引 | show index  from table_name;                                                                                |
| 全文索引 | ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);                                                 |

## 索引的分类

主键索引：索引列值唯一且非空，设定主键后数据库会自动建立主键索引，innodb为聚簇索引

```sql
--随表一起建立
CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),
  PRIMARY KEY(id)
);
--单独建立主键索引
ALTER TABLE customer add PRIMARY KEY customer(customer_no);
--删除主键索引
ALTER TABLE customer drop PRIMARY KEY ;
--修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引
```

唯一索引：索引列的值必须唯一，但允许有空值

```sql
--随表一起创建
CREATE TABLE customer(id INT(10) AUTO_INCREMENT, customer_no VARCHAR(20), customer_name VARCHAR(20),
PRIMARY KEY(id),
UNIQUE (customer_no)
);
--单独给表建立唯一索引
CREATE UNIQUE [INDEX] idx_customer_no ON customer(customer_no);
```

单值索引：一个索引只包含单列，索引列值可重复，一个表可以有多个单值索引。

```sql
--随表一起创建
CREATE TABLE customer(id INT(10) AUTO_INCREMENT, customer_no VARCHAR(20), customer_name VARCHAR(20),
PRIMARY KEY(id),
INDEX|KEY (customer_name)
);
--单独给表建立单值索引
CREATE  INDEX idx_customer_name ON customer(customer_name);
```

复合索引：一个索引包含多个列

```sql
--随表一起建立
CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),
  PRIMARY KEY(id),
  KEY (customer_no,customer_name)
);
--单独建立复合索引
CREATE INDEX idx_no_name ON customer(customer_no,customer_name);
```

> 复合索引遵循**最左前缀匹配**：如创建t1(name, gender, email) 的索引，相当于创建了t1(name), t1(name, gender), t1(name, gender, email)三个索引，只查(name),或(name，gender)也会使用此索引加速查找，但只查(gender)，(email)或者(gender,email)都不会使用此索引。
>

## 索引的创建时机

**适合创建索引的情况**

- **频繁**作为查询条件的字段应该创建索引
- 查询中与其它表关联的字段，**外键**关系建立索引
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
- 查询中**分组**或者**聚合**字段

**不适合创建索引的情况**

- 表记录太少
- 该字段只有离散的几个值，如：性别，季节
- 经常增删改的表或者字段
- Where条件里用不到的字段不创建索引
- 过滤性不好的不适合建索引

## 聚簇索引和非聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语”聚簇“表示数据行和相邻的键值聚簇的存储在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。

![image-20200811134509517](assets/image-20200811134509517.png)

聚簇索引的好处：

按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。

聚簇索引的限制：

对于mysql数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。

由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键索引。

为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量选用有序的id，而不建议用无序的id，比如uuid这种。

## 索引失效

①最左前缀匹配

使用复合索引，需要遵循最左前缀法则，从左到右依次匹配，当无法匹配时，后续字段不走索引。

```sql
CREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME);
```

![image-20200812000723933](assets/image-20200812000723933.png)

对于`explain select sql_no_cache * from emp where emp.name='abcd' and emp.age = 30;`优化器会自动优化顺序，使其对age字段也会走索引。

最左前缀匹配原理：索引的底层是一颗B+树，创建一个（a,b）的联合索引，联合索引的索引树为：

![image-20200812001035478](assets/image-20200812001035478.png)

存储索引时，先根据第一个字段进行排序，第一个字段相同时再对第二个字段排序，以此类推。

所有a相同的数据，其索引相邻，但所有b相同的数据则分散在各处。因此根据b字段查找，无法走索引，只能全表扫描。

②对索引列使用了计算、函数、类型转换(显式或隐式)，都会导致索引失效而转向全表扫描。

![image-20200812001751362](assets/image-20200812001751362.png)

```sql
create index idx_name on emp(name);
```

![image-20200812001901867](assets/image-20200812001901867.png)

> 字符串不加单引号，则会导致隐式转换。
>

③范围查询之后的字段不走索引

范围查询字段本身是走索引的，但后续字段不走索引，建议将可能做范围查询的字段的索引顺序放在最后

![image-20200812002032135](assets/image-20200812002032135.png)

④使用不等于导致索引失效

mysql 在使用不等于(!= 或者<>)时，有时会无法使用索引会导致全表扫描。

![image-20200812002327224](assets/image-20200812002327224.png)

⑤带not导致索引失效

![image-20200812002423941](assets/image-20200812002423941.png)

⑥like %开头不能走索引，%结尾可以走索引

![image-20200812002613262](assets/image-20200812002613262.png)

⑦使用or不走索引

![image-20200812002719708](assets/image-20200812002719708.png)

建议使用union all或union 代替or：

![image-20200812002749046](assets/image-20200812002749046.png)

练习题：建立索引(a,b,c)，判断各字段是否走索引

| Where语句                                               | 索引是否被使用                             |
| ------------------------------------------------------- | ------------------------------------------ |
| where a = 3                                             | Y,使用到a                                  |
| where a = 3 and b = 5                                   | Y,使用到a，b                               |
| where a = 3 and b = 5  and c = 4                        | Y,使用到a,b,c                              |
| where b = 3 或者 where b = 3 and c = 4 或者 where c = 4 | N                                          |
| where a = 3 and c = 5                                   | 使用到a， 但是c不可以，b中间断了           |
| where a = 3 and b  > 4 and c = 5                        | 使用到a和b， c不能用在范围之后，b断了      |
| where a is null and b  is not null                      | is not null 不走索引，所以 a 走索引，b不走 |
| where a <>  3                                           | 不能使用索引                               |
| where  abs(a) =3                                        | 不能使用 索引                              |
| where a = 3 and b  like 'kk%' and c = 4                 | Y,使用到a,b,c                              |
| where a = 3 and b  like '%kk' and c = 4                 | Y,只用到a                                  |
| where a = 3 and b  like '%kk%' and c = 4                | Y,只用到a                                  |
| where a = 3 and b  like 'k%kk%' and c = 4               | Y,使用到a,b,c                              |