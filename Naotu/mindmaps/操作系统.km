{
    "root": {
        "data": {
            "id": "root",
            "text": "操作系统"
        },
        "children": [
            {
                "data": {
                    "id": "44ff7f55-5f08-486d-bdad-6ba264f42fb2",
                    "text": "基础"
                },
                "children": [
                    {
                        "data": {
                            "note": "操作系统是硬件和软件的桥梁，本身也是一系列软件的集合，用于管理硬件资源，并为应用程序提供访问系统资源的接口。\n\n操作系统负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。",
                            "id": "8415d590d88b",
                            "text": "什么是操作系统"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。\n\n内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。\n\n用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。\n\n用户程序运行在用户态,操作系统内核运行在内核态。",
                            "id": "1cc383016673",
                            "text": "内核态与用户态"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "CPU从用户态到内核态的切换是通过**中断**(外中断)或**异常**(内中断)实现的。\n- 外中断：CPU执行指令以外的事件导致的中断，通常与当前程序本身无关。如IO中断，表示输入输出处理完成，时钟中断，表示时间片到。\n- 内中断：CPU执行指令内部导致的中断。常常与程序本身的错误引起，如地址越界、空指针、算术溢出、文件找不到等。",
                                    "id": "b4488033d43f",
                                    "text": "内核态和用户态的切换"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "应用程序借助操作系统访问磁盘、网络、CPU、内存等系统资源的过程称为系统调用，发生系统调用时，CPU需要从用户态切换到内核态。系统调用本身是一种(软)中断。",
                                    "id": "77b2a56d971f",
                                    "text": "系统调用"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "并发(concurrency)：单个CPU采用时间片轮转方式，在一段时间内同时执行多个任务，在宏观上看，多个任务在同时执行，在微观上，某一时刻只有一个任务在执行。\n\n并行(parallelism)：多个CPU同时执行多个任务，是严格意义上的多任务同时执行。\n\n> 并发并没有提高计算机的处理性能，但可以提高执行效率，即降低了某些进程的响应时间。",
                            "id": "f74d9d84e65f",
                            "text": "并发与并行"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "6b48121e92da8593430f9b74b5",
                    "text": "进程与线程"
                },
                "children": [
                    {
                        "data": {
                            "note": "**进程**是程序的一个运行实例，是资源分配的基本单元。一个进程实体由三部分组成：\n\n- 进程控制块(PCB)：描述、控制和管理进程的数据结构。PCB是进程存在的唯一标志。\n- 程序段\n- 数据段\n\n**线程**是CPU执行的基本单元。一个线程主要由线程ID、程序计数器、寄存器集合和栈组成。\n\n**比较**：\n- 进程类似一个container，而线程则是一个个task。一个进程包含一个或多个线程。这些线程共享该进程的内存空间，如方法区和堆。共享方便了线程间通信，但同时需要一套同步机制来处理线程安全问题。\n\n- 线程切换的时空开销远小于进程切换的时空开销。进程切换时涉及到大量资源的保存和恢复，而同一个进程中的线程切换只需要保存和恢复少量寄存器，开销小得多。\n\n- 一个Java进程，至少会有3个线程：main()主线程，gc()垃圾回收线程，异常处理线程。",
                            "id": "b7fa8281-f78f-4c07-9162-dbf86d404ab0",
                            "text": "进程与线程的比较"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息。\n\n![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210509020719-vk6o0k4.png)",
                                    "id": "3a3c653f779e",
                                    "text": "进程控制块(PCB)"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "引入进程：\n1.提高CPU的利用率，例如一个进程正在IO，就可以把CPU让给其他进程。\n2.提高并发度，现在一般都是多核电脑，使用多进程可以让多个任务并行执行，提高效率。\n\n---\n\n线程的不足：\n- 进程切换耗费大量资源，切换期间CPU资源被浪费。\n- 进程某部分任务阻塞会导致整个进程阻塞，即使其他任务不依赖所等待的资源。\n\n引入线程：弥补进程的不足，进一步提升CPU利用率和并发效率。\n\n\n1.切换开销：线程切换的时空开销远小于进程切换的时空开销。进程切换时涉及到大量资源(主要是PCB的各种表)的保存和恢复，而同一个进程中的线程切换只需要保存和恢复少量寄存器，时空开销小得多。\n2.通信机制：不同进程具有独立的地址空间，进程间通信比较麻烦。线程间共享所属进程的内存空间，同进程中的一个线程可以被其他线程感知，通信和同步更加方便，例如线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。",
                                    "id": "c21bbf2db68a",
                                    "text": "为什么引入进程和线程"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "* 需要频繁创建销毁的任务优先用线程\n* 需要进行大量计算时优先使用线程：大量计算耗费CPU，切换频繁。如图像计算，算法处理\n* 强相关的处理用线程，弱相关的处理用进程",
                                    "id": "fe1394ee8da1",
                                    "text": "什么时候用进程，什么时候用线程"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "1.孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。\n\n2.僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。",
                            "id": "9a3e1a2dbfa1",
                            "text": "孤儿进程和僵尸进程"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "当前占用CPU的任务由于时间片用完或自发让出CPU，另一个任务获得CPU准备执行的过程。上下文切换包括旧任务的切出和新任务的切入。涉及到状态的保存和恢复，对线程而言，一般是程序计数器和栈等资源，对进程而言，一般是进程控制块、堆等资源，还会经历从用户态到内核态，再从内核态到用户态的切换过程。\n\n切出： 一个线程被剥夺处理器的使用权而被暂停运行；\n\n切入： 一个线程被系统选中占用处理器开始或继续运行\n\n上下文切换**通常是计算密集型**的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。",
                            "id": "796dd7ac-7037-4e00-90f1-237dba216fc5",
                            "text": "上下文切换"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210403225301-jqaaf51.png)\n\n- 新建：进程刚被创建\n- 就绪：进程具备了处理器外的所有资源，万事俱备，只欠CPU\n- 运行：进程获得CPU时间片，正在运行的状态\n- 阻塞：进程等待某个非CPU资源或某个时间完成，此时即使CPU空闲，该进程也不能执行\n- 终止：进程运行完成或遇到异常而结束运行\n\n就绪→运行：获得时间片\n\n运行→就绪：时间片到期\n\n运行→阻塞：等待资源或事件\n\n阻塞→就绪：资源或事件就绪\n\n> 进程从运行到阻塞是一个主动行为，从阻塞到就绪是一个被动过程，需要被其他进程唤醒",
                            "id": "9d38fdf4-816f-4516-904c-64952cdb382f",
                            "text": "进程的状态与切换"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210404014934-qb6wk40.png)\n\nJava 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的一种：\n\n* 新建(New) :创建后尚未启动的线程的状态\n* 可运行(Runnable):可细分为就绪(ready)和运行中(running)\n* 阻塞(Blocked):阻塞于锁，**被动**放弃CPU\n* 等待(Waiting): **主动**放弃CPU,需要被其他线程唤醒\n* 超时等待(Timed Waiting):在等待一定时间后会由系统自动唤醒\n* 终止(Terminated):线程执行完成或遇到异常而结束执行",
                            "id": "60339a94c299",
                            "text": "Java线程的状态与切换"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "#### 管道\n\n管道其实就是一个固定大小的缓冲区，在Linux中大小为4kb(管道符`|`)。管道的特点：\n\n1.**半双工**通信，数据只能单向流动，严格遵循FIFO，要实现双向通信，需要定义两个管道。\n2.管道中的数据被读取后就被丢弃。\n3.非空不能写，非满不能读，读写不能同时进行。\n4.只支持无格式字节流。\n\n管道分为无名管道和有名管道，无名管道只用于父子进程或子进程间通信；有名管道允许任意进程间通信。\n\nLinux中创建有名管道：\n\n```plaintext\nmkfifo test\necho 666 > test\ncat < test\n```\n\n#### 消息队列(message queue)\n\n消息队列存放着一个个格式化的消息体，进程间通过系统提供的发送消息和接收消息原语进行消息交换。消息队列克服了管道只能承载无格式字节流以及缓冲区大小受限等缺点。当两个进程需要频繁交换大量数据时，消息队列显得不够快速高效。\n\n#### 共享内存(shared memory )\n\n共享内存就是多个进程中申请一块虚拟地址空间，并映射到同一块内存物理地址，这段共享内存由一个进程创建，但多个进程都可以访问。特点：\n\n1.共享内存是**最快的进程间通信方式**。避免了消息在用户空间和内核空间的来回拷贝。\n\n2.需要某种同步机制实现共享内存的互斥访问，如互斥锁、信号量和信号。\n\n#### 信号量(semaphore )\n\n信号量实际上是一个计数器(≥0)，主要用于实现进程间以及同一进程内不同线程间的同步和互斥，而不是存储通信数据本身。\n\n信号量定义了两种操作，即pv操作，p操作为申请资源，v操作为归还资源。\n\n#### 信号 (signal )\n\n信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，接收进程执行后续相应操作。\n\n#### 套接字(Socket)\n\n套接字封装了ip和端口，用于不同主机的进程间通信。在网络编程中随处可见。",
                            "id": "da1b88dd6403",
                            "text": "进程间通信方式"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "同一进程中的线程间以该进程的内存空间为共享内存，因此线程通信主要关注访问共享内存的互斥和同步机制。\n\n操作系统一般有下面三种线程同步的方式：\n\n- 锁：主要有互斥锁、读写锁。\n\t- 互斥锁实现了共享资源被一个线程独占，防止数据被并发修改。Java中的 synchronized、volatile和各种 Lock(ReentrantLock/LockSupport) 都是这种机制。\n    - 读写锁允许多个线程同时读取共享数据，但不能同时写，可以通过CopyOnWrite实现MVCC，以支持写时读。\n- 信号量：线程间也可以使用信号量控制对共享资源的并发访问度，有 accquire() 和 release() 方法(pv操作)；类似的还有CountDownLatch，控制线程等待，可以用来等待多个线程执行任务后进行汇总\n- 通知机制：在java中体现为notify/notifyAll/wait()或ReentranLock结合Condition的await()和signal()方法\n\n```plaintext\nwait(): 当前线程释放CPU和锁，并进入等待池，等待被唤醒，需处理异常：InterruptedException\nnotify(): 随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会\nnotifyAll(): 让所有处于等待池的线程全部进入锁池去竞争获取锁的机会\n//这三个方法定义在Object类中，而非Thread类中。\n//只用于synchronized方法或代码中，否则会报异常：`java.lang.IllegalMonitorStateException`。\n//调用者必须是synchronized所用的同步监视器，如`锁.wait()`，否则会报异常：`java.lang.IllegalMonitorStateException`。\n等待池WaitSet：调用了wait方法的线程会释放锁并进入等待池，在等待池的线程不会竞争锁。（休息的池子）\n锁池EntryList：在等待池被唤醒的线程，或试图获取正在被占用的锁的线程，需要在锁池等待。（准备抢锁的池子）\n```",
                            "id": "dfee3c6fd08f",
                            "text": "线程间通信方式"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "f43d7fc53f75",
                            "text": "信号量PV"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "ec2d8f2a67f2",
                                    "text": "如何实现同步和互斥"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "多个任务(进程或线程)因竞争资源而造成的一种循环等待的僵局，若无外力作用，这些任务都将无法向前推进。",
                            "id": "492fb26b-2b41-4ca1-82e3-24c912cf7f63",
                            "text": "死锁"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "1.互斥：一个资源同时只能被一个线程占有；\n2.请求与保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放；\n3.不可剥夺：进程已经获得的资源，在未使用完之前，不能强行剥夺；\n4.循环等待：资源依赖链形成环路。",
                                    "id": "1e49e155-0a92-43b2-8cad-bfe656f833fa",
                                    "text": "死锁的四个必要条件"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "**死锁的预防**：破坏导致死锁的条件，实现简单，但效率低下，资源利用率低。\n\n1.破坏互斥条件：这个条件没有办法破坏，因为我们⽤锁本来就是想让他们互斥的。\n2.破坏请求与保持条件：⼀次性申请所有的资源。直到所有资源就绪才开始运行。被申请的资源可能被严重浪费，且容易导致饥饿现象，当个别资源长期被某个任务占用，等待该资源的进程迟迟不能开始运行。\n3.破坏不可剥夺条件：占⽤部分资源的线程再申请其他资源时，若申请不到，可以主动释放其占有的资源。可用于便于保存和恢复的资源，如CPU寄存器及内存资源，一般不能用于打印机之类的资源。\n4.破坏循环等待条件：按序申请资源。需要给资源编号，然后必须按编号递增的顺序申请资源。不够灵活，不利于编程。\n\n**死锁的避免**：运行资源动态分配，在分配资源前，先检查资源分配安全性，以避免发生死锁。这种方法所施加的条件较弱，可以获得较好的系统性能。\n\n**死锁的检测与解除**：不采取任何限制措施，允许进程在运行过程中发生死锁。通过系统的检测机制及时检测死锁的发生，并采取相应措施解除死锁。\n\n- 资源剥夺法：挂起某些死锁进程(线程)，并抢占其资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。\n- 撤销进程法：强制撤销部分甚至全部死锁进程(线程)并剥夺其资源。撤销的原则可以按进程优先级和撤销代价的高低进行。\n- 进程回退法：让一个或多个进程(线程)回退到足以避免死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。",
                                    "id": "498d87b303f0",
                                    "text": "如何解决死锁问题"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "使用jconsole图形化工具直接检查死锁\n\n使用jstack命令行分析线程Dump信息\n\n主要是两个命令配合起来使用，定位死锁。\n\n**jps**指令：`jps -l`可以查看运行的Java进程。\n\n```java\n9688 thread.DeadLockDemo\n12177 sun.tools.jps.Jps\n```\n\n**jstack**指令：`jstack pid`可以查看某个Java进程的堆栈信息，同时分析出死锁。\n\n```java\n=====================\n\"Thread AAA\":\n\tat xxxxx\n\t- waiting to lock <0x000111>\n\t- locked <0x000222>\n\tat java.lang.Thread.run\n\"Thread BBB\":\n\tat xxxxx\n\t- waiting to lock <0x000222>\n\t- locked <0x000111>\n\tat java.lang.Thread.run\nFound 1 deadlock.\n```",
                                    "id": "b56cf37eb4f0",
                                    "text": "如何分析线程死锁"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "",
                            "id": "ba40d727-c01a-4c0a-be7a-e2b31cc794ec",
                            "text": "处理机调度"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "1.当前运行的进程运行结束。\n2.当前运行的进程由于某种原因阻塞。\n3.执行完系统调用等系统程序后返回用户进程。\n4.在使用抢占调度的系统中，具有更高优先级的进程就绪时。\n5.分时系统中，分给当前进程的时间片用完。",
                                    "id": "81ef3e04f0f8",
                                    "text": "调度时机"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "1.在中断处理程序执行时。\n2.在操作系统的内核程序临界区内。\n3.其它需要完全屏蔽中断的原子操作过程中。",
                                    "id": "4611acdabe90",
                                    "text": "不能进行调度的情况"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "1.CPU利用率\n2.系统吞吐率，即单位时间内CPU完成的作业的数量。\n3.响应时间。\n4.周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键\n   + 平均周转时间\n\n   + 带权周转时间\n\n   + 平均带权周转时间",
                                    "id": "00d9763b1318",
                                    "text": "调度策略的基本设计指标"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "1.**先到先服务(FCFS)** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n2.**短作业优先(SJF)** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n3.**时间片轮转** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n4.**多级反馈队列** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。\n5.**优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。",
                                    "id": "9836b2eb179e",
                                    "text": "调度算法"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "42f44298-da0a-4ea6-8cfb-c179217de464",
                    "text": "IO模型"
                },
                "children": [
                    {
                        "data": {
                            "id": "f4d0ba89-94c0-40c1-acfa-fe693aadd9ae",
                            "text": "BIO"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "a9ba3763-0894-45b9-84cd-53eb5e3bd80b",
                            "text": "AIO"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "32c8bf31-b21e-405f-8326-8a1673edf650",
                            "text": "NIO"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "c4ddabd9-c14a-4f1e-bf80-3081fea74d55",
                            "text": "IO多路复用"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "2db5f43a-2282-4798-888f-265f063e6335",
                                    "text": "epoll"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "370bc24b-e8f7-43c4-a3d0-1fba48fbaa52",
                                    "text": "select"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "13579c4f-3fa5-481b-b46d-d4b167036d08",
                                    "text": "poll"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d99be22f-f9e4-44ed-ad02-79c09a258063",
                            "text": "信号驱动IO"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "7498bff5-a3b5-4214-a937-12d2323553b0",
                    "text": "内存管理"
                },
                "children": [
                    {
                        "data": {
                            "id": "fbd37539-f9d5-49a0-a2e8-b39a9b3ad997",
                            "text": "块式，页式，段式"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "4a99a61c-c21c-4f16-9e7b-f10e2525a6fe",
                            "text": "快表"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "0fa961e9-19b4-418e-9699-9a2ad06733c1",
                            "text": "虚拟内存"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "3ef2155c-1c92-46bc-b579-e297560c7ae7",
                                    "text": "虚拟地址和物理地址"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "**时间局部性**：刚执行过的指令，可能很快被再次执行，刚访问过的数据，可能很快被再次访问，原因是程序中常常存在大量循环操作。\n\n**空间局部性**：某个地址刚被访问，其临近的地址可能也很快被访问，因为指令通常是顺序存放，顺序执行的。\n\n利用时间局部性，设计了多级高速缓存，利用空间局部性，设计了虚拟内存(内存+外存)",
                                    "id": "1b380a23-6e14-4d64-927e-e1fda552699a",
                                    "text": "局部性原理"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "f877189f-a48e-4df3-9309-00c440148684",
                                    "text": "虚拟内存技术的实现"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "447b257e-47cb-484f-a24c-c643039c80a3",
                                            "text": "请求分页存储管理"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "19aee075-ae73-4bad-bc9f-9a26916aaee5",
                                            "text": "请求分段存储管理"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d5e22134-d110-47ea-bbe0-e1797a0ebc17",
                                            "text": "请求段页式存储管理"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "当所访问页不在内存中，且内存已满时，需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。常见的缺页置换算法如下：\n\n**先进先出(FIFO)算法**：\n\n+ 思路：置换最先调入内存的页面。\n\n+ 实现：队列记录入内存的先后次序，先进先出。\n\n+ 特点：实现简单但性能较差：调出的页面可能是经常访问的\n\n**最近最少使用算法**（Least Recently Used, LRU）:\n\n+ 思路： 根据时间局部性原理，刚被访问的页面，可能马上又要被访问；因此缺页时淘汰最近最少使用的页面。\n\n+ 实现：记录每个页面的上一次访问时间，选择上一次使用到当前时间最长的页面\n\n+ 特点：是当前最常采用的算法，接近最优效果，但需要寄存器和栈等硬件支持，维护开销较大。\n\n**最不常用算法**（Least Frequently Used, LFU）\n\n+ 思路：缺页时，置换访问次数最少的页面\n\n+ 实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面\n\n+ 特点：开销较大且性能不佳，开始时频繁使用，但以后不使用的页面很难置换",
                                    "id": "85bff8bb-a482-4870-bf7a-6a902a9339d2",
                                    "text": "页面置换算法"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "fresh-green-compat",
    "version": "1.4.43"
}