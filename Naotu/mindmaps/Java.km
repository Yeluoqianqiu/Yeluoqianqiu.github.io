{
    "root": {
        "data": {
            "id": "root",
            "text": "Java"
        },
        "children": [
            {
                "data": {
                    "id": "24927e2a-d504-44aa-85c5-7118706efbf0",
                    "text": "Java基础",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "85b6393196fc",
                            "text": "JDK和JRE"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "9c6534cf999e",
                                    "text": "JRE：Java运行环境，提供了Java运行所需的环境"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "134b965edd9c",
                                    "text": "JDK：Java开发工具包，包含JRE和Java的开发环境"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "6348ebe8e8eaa16b61de0b77a4",
                            "text": "数据类型"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "![image.png](https://yeluoqianqiu.github.io/assets/image-20210401202023-xx7jsvz.png)",
                                    "id": "1b6e6011-3846-4787-a5d3-8ab475886f7a",
                                    "text": "八种基本数据类型"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "基本数据类型的值直接存储在栈中。\n\n引用数据类型的对象存储在堆中，而栈中的值是对象在堆中的地址。",
                                            "id": "78b98906-2985-4db8-ae2d-1a39d6f85726",
                                            "text": "基本数据类型和引用数据类型区别"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "引入包装类是为了实现面向对象的完整性。\n\nJava 基本类型的包装类，除了浮点型的Float和Double，都实现了缓存池技术。各自的默认缓存池为：\n\n- Byte,Short,Integer,Long：[-128，127]\n- Character：[0,127]\n- Boolean：True，False\n\n创建包装类对象时，若值在缓存池范围，则总是指向缓存池中的那个对象，否则会创建新的对象。为啥整型包装类把缓存池设置为[-128，127]？性能和资源之间的权衡。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\nInteger 的缓存池 IntegerCache，上界默认是 127，但是这个**上界是可调的** ，在启动 jvm 的时候，通过 `-XX:AutoBoxCacheMax=<size>`来指定这个缓存池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。\n\nIntegerCache源码：\n\n```java\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```",
                                            "id": "7da86d84-af88-4d0a-801d-3d67017855bd",
                                            "text": "包装类和缓存池"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "* 装箱：将基本数据类型转化为对应的包装类，底层调用了`Integer.valueOf(i)`\n* 拆箱：将包装类转换为对应的基本数据类型，底层调用了`x.intValue()`\n\n```java\nInteger x = 2;     // 装箱 调用了 Integer.valueOf(2)\nint y = x;         // 拆箱 调用了 x.intValue()\n```",
                                                    "id": "54de85b3-8742-473d-b609-56adacc640d7",
                                                    "text": "自动装箱与拆箱"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "note": "new Integer(123) 与 Integer.valueOf(123) 的区别在于：\n\n* new Integer(123) 每次都会新建一个对象；\n* Integer.valueOf(123) 会先判断值是否在缓存池中，在则直接返回缓存池的内容。\n\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n示例：\n\n```java\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n```",
                                                    "id": "9c2191774cb5",
                                                    "text": "new Integer(123)与Integer.valueOf(123)的区别"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "String 对象的两种创建方式：\n\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n这两种不同的创建方法是有差别的。\n\n第一种方式是在常量池中拿对象；\n第二种方式是直接在堆内存空间创建一个新的对象。\n记住一点：只要使用 new 方法，便需要创建新的对象。\n\n再给大家一个图应该更容易理解，图片来源：https://www.journaldev.com/797/what-is-java-string-pool：\n\n￼\n",
                                    "id": "75b0ead3-47f7-4db8-8cb4-a87babcfe61e",
                                    "text": "String 类"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串对象“abc”。如果池中没有字符串常量“abc”，那么它将首先在常量池中创建，然后在堆空间中创建一个新对象，因此将创建总共 2 个字符串对象。",
                                            "id": "2d7ef560-8ba9-4623-86f4-62c8b449b506",
                                            "text": "String s1 = new String(\"abc\");这句话创建了几个字符串对象？"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "| 可变性   | String是不可变字符串，每次操作需要创建新的字符串对象，StringBuffer和StringBuilder是可变字符串，对字符串自身进行改动，不用创建新对象 |\n| -------- | ------------------------------------------------------------ |\n| 线程安全 | StringBuilder线程不安全，StringBuffer和String线程安全        |\n| 效率     | StringBuilder > StringBuffer >> String                       |",
                                            "id": "77a3038abc5d",
                                            "text": "String、StringBuffer、StringBuilder的比较"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "aedcbfad1f4a",
                                    "text": "Object类"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。\n深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\n\nObject.clone()默认是浅拷贝。\n\n",
                                            "id": "9197b00f-4d58-456f-98c9-ab3176ea3c06",
                                            "text": "深拷贝与浅拷贝"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "`==`：\n\n* 基本数据类型变量比较时：比较两个变量保存的值是否相等(类型可不同)\n* 引用数据类型变量比较时：比较两个对象的地址值是否相等(是否指向同一个对象)\n\n`equals()`：若未重写，则为Object类的equals()方法，效果同`==`\n\n> String/Date/File和包装类都重写了Object类中的equals()方法，转而比较两个变量保存的内容值是否相同。\n\n重写equals()的步骤\n\n* 检查是否为同一个对象的引用，如果是直接返回 true；\n* 检查是否是同一个类型，如果不是，直接返回 false；\n* 将 Object 对象进行转型；\n* 判断每个关键域是否相等。\n\n```java\npublic class EqualExample {\n\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    }\n}\n```",
                                            "id": "f767d6ad-eefc-43a4-934e-6a2699d01a2c",
                                            "text": "equals与=="
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "hashCode() 返回对象的哈希值。**等价的两个对象，哈希值一定相同，但是哈希值相同的两个对象不一定等价** ，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。\n\n**在重写equals() 方法时应当总是重写hashCode() 方法，保证等价的两个对象哈希值也相等。**",
                                            "id": "9add7f9a-4f03-44e9-9869-8097ea28b321",
                                            "text": "hashCode()"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "6b48121e92da8593430f9b74b5",
                            "text": "面向对象三大特性"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "封装：隐藏对象的内部细节，只对外暴露一些访问接口\n为什么要封装：程序设计追求高内聚、低耦合。可以对提供的接口加入控制逻辑，限制外部不合理访问。\n实现：封装通过权限修饰符实现。",
                                    "id": "49a44234-a44d-45fb-bd04-cc1260180e30",
                                    "text": "封装"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "继承：基于已有的类创建新类\n特点：\n- 子类继承了父类所有的属性和方法，但不能访问父类的私有属性和方法。\n- 子类可以对父类的方法进行重写，或声明新方法进行功能的扩展\n- 一个父类可以被多个子类继承，但一个类只能有一个父类(**单继承** )\n- Java支持多重继承，如：`Son extends Father{};Father extends GrandFather{}`;\n- 如果没有显式地声明一个类的父类，其默认继承于java.lang.Object类\n\n作用：复用，扩展，是多态的基础\n弊端：类之间产生联系，违背了低耦合，父类变化会导致子类变化。",
                                    "id": "0662ed92-b114-4b45-8b12-70d3aa445ad4",
                                    "text": "继承"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "重载：一个类中的同名方法，因参数的类型、个数或顺序不同，声明的不同方法\n\n重写：子类对父类同名同参方法的覆写，需满足里氏替换原则\n\n> 里氏替换原则：\n>\n> * **子类方法访问权限大于等于父类方法的访问权限**\n> * 子类方法的返回类型必须小于等于父类的返回类型\n>\n> * 子类方法抛出的异常类型必须小于等于父类抛出的异常类型\n>\n> **以上三点保证了多态的正确性**。\n\n比较：\n\n- 重载发生在一个类中的多个同名方法之间，重写发生在父类和子类的同名方法之间\n- 重载发生在编译期间，重写发生在运行期间(从编译和运行的角度看方法的重载和重写，可详述)\n- final方法不能被重写，父子类同名的private/static方法不是重写\n\n可以用注解 `@Override`检验重写方法是否正确。",
                                            "id": "cbe962af9318",
                                            "text": "重载与重写"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "多态的概念：父类的对象引用指向了子类实例，由于动态绑定，具体指向哪个子类的实例只有在运行期间才能确定\n\n多态的前提：存在继承与同一个父类的多个子类，且各个子类对父类某方法进行了重写，使得父类的对象引用指向不同的子类实例时，调用该方法，可以实现不同的效果。\n\n多态的作用：提高代码的通用性，即**接口重用**",
                                    "id": "b11dc061-2d58-4117-bde4-c23767daeb38",
                                    "text": "多态"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "725e342f3540",
                                            "text": "动态绑定与虚拟方法调用"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "共性：都不能直接实例化，只能被子类继承或实现后实例化\n\n区别：\n\n|          | 抽象类                                                       | 接口                                                         |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 组成     | 构造方法、抽象方法、普通方法、常量、变量                     | 常量、抽象方法、(jdk8：默认方法、静态方法)、(jdk9：私有方法，私有静态方法) |\n| 使用     | 子类只能继承(extends)一个抽象类                              | 子类可以实现(implements)多个接口                             |\n| 设计模式 | 模板方法，作为一种模板                                       | 简单工厂、工厂方法、代理模式，作为一个标准或表示一种能力     |\n| 使用场景 | 子类和父类没有逻辑上的相关关系，父类只是作为一种标准或能力，例如实现了Comparable接口的类都有比较的能力；需要使用多继承时 | 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 |\n\n选择：当抽象类和接口都可以时，优先使用接口，可以避打破单继承的局限，也能降低子类和父类之间的耦合度，便于日后维护。\n\n> 在开发中，常看到一个类不是去继承一个实现好的类，而是要么继承抽象类，要么实现接口。",
                            "id": "c9d71957-a049-4eaa-884e-c1b4c5dbfb7f",
                            "text": "接口和抽象类"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "42f44298-da0a-4ea6-8cfb-c179217de464",
                            "text": "常见关键字"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "可以用于修饰类、方法、变量。\n\n修饰类时：此类不能被其他类继承，表示该类不能再被扩充功能。\n\n* 举例：String/System/StringBuffer\n\n修饰方法时：此方法不能被子类重写。\n\n* 举例：Object.getClass()\n\n修饰变量时：此变量的值不能被修改，即常量，变量名全大写\n\n* 修饰成员变量：必须在声明时或构造器中或代码块中**显式赋值**，不能使用默认值，也不能调用`对象.属性`或`对象.方法`赋值。\n* 修饰局部变量：特别注意用于形参时，被实参赋值后，后续不能改变。\n\nstatic final 常用来修饰全局常量。\n\n**将引用数据类型变量设为final，只是表示该变量不能指向其他对象，但当前所指的对象本身是可变的。**\n\n一个类中的所有private方法都被隐式的声明为final：`private void func(){}`相当于`private final void func(){}`。\n\n",
                                    "id": "737cce66-e6d0-40db-b52e-bc4f26bb0796",
                                    "text": "final"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "**final**：修饰符（关键字）。如果一个类被申明为final,意味着它不能再派生出新的子类，不能作为父类被继承，因此一个类不能既被声明为abstract的，又被声明为final的。将变量和方法声明为final变量的，可以保证它们在使用中不被改变。被声明为final的变量必须在申明时给定初值，而在以后的引用中只能读取不可以被修改。被申明为final的方法也同样只能使用不能重载。    \n\n**finally**：在异常处理时提供finally块来执行任何清除操作。如果抛出一个异常，那么相匹配的catch子句就会执行，然后控制就会进入finally块（如果有的话）。    \n\n**finalize**：方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做好必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用的情况下对这个对象的调用。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象的调用\n",
                                            "id": "33d8da72-49c7-41d2-9979-7f1bf9f7a1fb",
                                            "text": "final,finally,finalize的区别"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "当遇到下面情况不会执行。\n\n- 当程序在进入try语句块之前就出现异常时会直接结束。\n- 当程序在try块中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码。\n\n其它情况下，在try/catch/finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。",
                                            "id": "8007ccc44a24",
                                            "text": "finally是否一定会执行"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "static关键字：用于修饰属性、方法、代码块、内部类。被static修饰的成员属于类本身，为整个类的所有实例所共享。\n\n* static成员既可通过类来调用，也可通过实例来调用；非static成员只能通过实例来调用。\n* 由于static成员的创建早于实例对象，static方法中只能调用static属性和方法，且不能使用this和super关键字。\n\n应用场景：\n\n* 被多个对象共享的属性应声明为static的\n* 类中的常量也常常声明为static的，如Math.PI\n* 工具类中的方法，习惯上声明为static的，如：Math/Arrays/Collections",
                                    "id": "4e059248-b6f0-43c7-8381-05431393138f",
                                    "text": "static"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "this是本类对象的引用，super是本类的父类的引用（不仅限于直接父类）。\n\n**this和super都不能出现在static修饰的方法中。**",
                                    "id": "12164286-8135-475b-a389-aeb647a3cf92",
                                    "text": "this和super"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "类访问权限：在其他类中可以用这个类创建实例\n\n* 外部类：要么用public修饰，要么default(缺省)，不能使用private和protectd修饰。\n* 内部类：类中定义的类，可以看作一个成员\n\n成员访问权限：其它类可以用这个类的实例访问到该成员\n\n* private：限制该成员只能在本类中可见。常用于修饰私有属性和辅助方法。\n* default：无修饰符修饰的成员，允许同包的其他类访问，称为**包访问权限** 。\n* protected：支持包访问权限且可以被其他包的子类访问，**常用于修饰希望被子类重写的方法。**\n* public：可以被整个project下的所有类和对象访问\n\n",
                            "id": "157c1b09-abb3-4a59-9a4d-38df042f3380",
                            "text": "Java四种访问权限区别"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "* 类中绝大多数成员变量、辅助方法都应该使用private修饰；\n* 父类中希望被子类重写的方法应该使用protected修饰；\n* 一些static修饰的、类似全局变量的成员变量，可以考虑使用public修饰；\n* 希望暴露出来给其他类自由调用的方法应该使用public修饰，如：\n* **类的构造器** 通常使用public修饰，以便在其他地方创建该类的实例；\n* **大部分外部类** ：通常都希望被其他类调用。",
                                    "id": "13ab6349f935",
                                    "text": "访问权限设置原则"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "539c15a2-6f4e-4f35-b668-4173663d9f55",
                            "text": "泛型"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "泛型主要用在集合中，在推出泛型之前，集合中存储的是Object对象，需在使用前进行强制类型转换，不方便，如果放入了错误类型的对象，在进行类型转换时，会出现`ClassCastException`，泛型确保只能放入正确类型的对象，并且自动进行类型转换，实现了**安全、便捷地重用代码**。",
                                    "id": "c69de7a4-7d51-47c5-92e2-f34190705c04",
                                    "text": "存在的意义"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "1.不能实例化泛型类。\n2.静态变量或方法不能引用泛型类型变量，但静态泛型方法是可以的。原因：泛型要在实例化时才指定具体类型，静态方法不用实例化就能使用。\n3.基本类型无法作为泛型类型，应使用其包装类。\n4.无法使用`instanceof`关键字判断泛型类的类型。\n5.泛型数组可以声明，但无法直接实例化，需借助强制类型转换。\n6.泛型类不能继承Exception或者Throwable\n7.不能捕获泛型类型限定的异常但可以将泛型限定异常抛出。\n8.A是B的父类或父接口，`G<A>`和`G<B>`不具备继承关系，`A<G>`和`B<G>`有继承关系。如：\n\n```java\npublic void testGenericAndSubClass() {\n        List<Person> personList = null;\n        List<Man> manList = null;\n        // personList = manList;(报错)\n    }\n```\n\n9.若父类有泛型，子类在继承父类时，可以选择是否对泛型指定具体类型，此外，还可以增加自己的泛型。如：\n\n```java\nclass Father<T1, T2> {\n}\n// 子类不保留父类的泛型\n// 1)没有类型 擦除\nclass Son1 extends Father {// 等价于class Son extends Father<Object,Object>{...}\n}\n// 2)全部指定具体类型\nclass Son2 extends Father<Integer, String> {\n}\n// 子类保留父类的泛型\n// 1)全部保留\nclass Son3<T1, T2> extends Father<T1, T2> {\n}\n// 2)部分保留\nclass Son4<T2> extends Father<Integer, T2> {\n}\n```\n",
                                    "id": "7b25fb1a-33e0-4257-840b-087b3cca3729",
                                    "text": "泛型注意事项"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "泛型是通过**类型擦除**来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如`List<String>`在运行时仅用一个`List`来表示。这样做的目的，是为了兼容JDK1.5之前的版本。",
                                    "id": "7d940070-79fc-43d6-b7a4-ac44db6ca380",
                                    "text": "泛型是如何实现的"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "限定通配符：限定了泛型类型的上界和下界，因此必须用限定内的类型来进行初始化，否则会导致编译错误。\n\n- 限定上界：`<? extends T>`，类型必须是`T`或其子类，如`List<? extends Number>`可以接受`List<Integer>`。\n- 限定下界：`<? super T>`，类型必须是`T`或其父类，如`List<? super String>`可以接受`List<Object>`。\n\n非限定通配符：`<?>`，表示可以接受任意类型，如`List<?>`可以接受`List<String>`、`List<Ojbect>`。",
                                    "id": "d512b9ec6997",
                                    "text": "泛型通配符"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "233266ed97d6",
                    "text": "Java集合",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "note": "Collection接口继承自java.lang.Iterable接口，是List/Set/Queue等接口的父接口。\n集合类对象都可以调用`iterator()`方法生成迭代器对象用于遍历。\n![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210402195330-9f4l1be.png)",
                            "id": "85d814b8fb39",
                            "text": "Collection"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "List弥补了数组长度不可变的局限性。其元素有序、可重复。",
                                    "id": "ec30f31e3f12",
                                    "text": "List"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "底层使用`Object[]数组`存储，线程不安全。\n\n创建：\n\n- JDK1.7：ArrayList类似于饿汉式，实例化时直接创建一个初始容量为10的数组。\n- JDK1.8：ArrayList类似于懒汉式，实例化时创建一个长度为0的数组，当添加第一个元素时，才创建一个初始容量为10的数组。\n\n扩容：添加元素时如果没有剩余空间，则扩容为原容量的1.5倍，将原数组中的数据复制到新数组中。",
                                            "id": "7d519169578f",
                                            "text": "ArrayList"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "1.ArrayList底层为动态数组，LinkedList底层为双向链表。\n2.对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于插入和删除操作，LinkedList比较占优势，因为ArrayList要移动数据。\n3.两者都不是线程安全的",
                                                    "id": "228a17f43567",
                                                    "text": "ArrayList与LinkedList的比较"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "note": "底层使用`双向链表`存储，线程不安全，适合需要频繁插入、删除元素的场景",
                                            "id": "c133779c39d5",
                                            "text": "LinkedList"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "古老实现类，底层使用`Object[]数组`存储，线程安全(synchronized)，但效率低.",
                                            "id": "ba2aaf352008",
                                            "text": "Vector"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "Vector和ArrayList的最大区别在于Vector是线程安全的，因此开销比ArrayList要大，效率较低。正常情况下,大多数的Java程序员使用 ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。",
                                                    "id": "b427c7517433",
                                                    "text": "Vector与ArrayList的区别"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d2d270e18e22",
                                            "text": "其他线程安全的List"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "278070818639",
                                                    "text": "Collections.synchronizedList"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "note": "juc包下的类，是ArrayList的线程安全解决方案， 读操作不加锁，写操作通过ReentrantLock加锁，实现线程安全。\n\nCopyOnWrite是一种读写分离的思想。往一个容器添加元素的时候，不直接往当前容器Object[]中添加，而是先复制一份到新的容器Object[] newElements，在新容器里添加元素，添加完成后，再将原容器的引用指向新容器 `setArray(newElements);`。这样做的好处是使得CopyOnWrite容器支持并发读写，适合读多写少的场景。\n\n代价是需要占用双倍内存且不能读到实时更改，不适合对实时读取要求高的场景。",
                                                    "id": "faede87563a0",
                                                    "text": "CopyOnWriteArrayList"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "Set集合中的元素无序、不重复。\n- 无序性：元素的遍历顺序根据底层数据结构不同而不同，与添加顺序无关。",
                                    "id": "07fe2592f4b9",
                                    "text": "Set"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "底层HashMap，线程不安全，元素可为null",
                                            "id": "f5b791dc5b02",
                                            "text": "HashSet"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "HashSet的子类，底层仍然用HashMap存储元素，但同时使用了一个双向链表维护了元素的添加顺序，实现了遍历顺序为添加顺序",
                                                    "id": "d29027ddbdbf",
                                                    "text": "LinkedHashSet"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "note": "底层使用红黑树存储元素，使得集合元素保持排序状态。",
                                            "id": "0a8240c65dc8",
                                            "text": "TreeSet"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "087678672443",
                                            "text": "线程安全的Set：CopyOnWriteArraySet"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "6d88550ec35d",
                                    "text": "Queue"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "用于保存键值对，key和value支持任意引用类型",
                            "id": "ff84b9fb5d78",
                            "text": "Map"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "Map的主要实现类，线程不安全；**允许存储null的key和value**\n\nJDK8相较于JDK7在底层实现方面的不同：\n- 实例化时数组懒加载\n- 链表添加元素：JDK7使用头插法，JDK8使用尾插法\n- 底层数据结构：JDK7为数组+链表，JDK为数组+链表+红黑树\n\n扩容阈值：0.75\n扩容为2倍\n树化：链长超过8且桶长超过64\n树转链：树长度小于6\n\n",
                                    "id": "995c8e8cfd12",
                                    "text": "HashMap"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "HashMap的子类，在原HashMap底层结构的基础上为每个元素添加了两个指针，实现了按添加顺序遍历，常用于需要**频繁遍历**的场景，可用于实现LRU",
                                            "id": "26441bbc37d5",
                                            "text": "LinkedHashMap"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "底层使用**红黑树**，元素按key值有序排列",
                                    "id": "cc31e1c36b0c",
                                    "text": "TreeMap"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "Map的古老实现类，线程安全，但效率低；**不允许存储null的key和value**",
                                    "id": "9109aba851df",
                                    "text": "Hashtable"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "常用来处理配置文件，要求key和value都是String类型",
                                            "id": "3611823c64f6",
                                            "text": "Properties"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "JDK1.7 分段锁Segment[]\nJDK1.8 数组+链表+红黑树  CAS+synchronized",
                                    "id": "c07f6d84fbf9",
                                    "text": "线程安全的ConcurrentHashMap"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "b8f6e07db294",
                            "text": "源码解析"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "1.首先计算key的hash值，然后调用putVal方法\n2.是否首次添加元素，首次则创建一个长度为16的Node数组。\n3.不是首次，则根据hash值和数组长度找到得到应该插入的位置：(n-1)&hash\n    3.1若该位置上为空，则直接插入；\n    3.2若不为空，先判断头结点的key与插入key相同，是则直接覆盖，否则判断节点类型是链表还是红黑树：\n\t3.2.1若为红黑树则将新节点放入树中；\n\t3.2.2若为链表，则与链表上的每个结点依次比较，先比较hash值，hash值相同再调用equals方法，若为true，说明key相等，则用新value替换旧value，比较到链尾也没有发现重复key，则在链表尾部添加该键值对。添加完成还需要判断是否需要树化。\n4.添加完成后判断是否需要扩容。",
                                    "id": "acc41576e190",
                                    "text": "HashMap的put()方法"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "f38fd176b188",
                                    "text": "ConcurrentHashMap"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "f510328df6aa",
                                    "text": "ArrayList"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "836194309ece",
                                    "text": "CopyOnWriteArrayList的add()方法"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "3f7f9097-0091-4f88-ab92-8244d2710a36",
                    "text": "Java多线程",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "note": "两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁 。\n两者都可以暂停线程的执行。\nwait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。\nwait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。\n\n",
                            "id": "e692c5da-20be-4887-bdc4-2d4ac4b6781d",
                            "text": "sleep()和 wait()的区别和共同点"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。\n\n",
                            "id": "7e5f743e-f3eb-4f32-bafe-43205baae429",
                            "text": "为什么调用 start()时会执行 run()，为什么不直接调用 run()？"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "note": "线程池提供了一种管理资源的手段，基于池化思想，能有效提高对资源的利用率。使用线程池的好处：\n\n- 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁的开销。\n- 提高响应速度：当任务达到时，不用等待创建新的线程就能立即执行。\n- 方便管理线程：可以控制核心线程数，最大并发数，自定义拒绝策略。\n\n体系架构：\n![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210406152406-a41l0p0.png)",
                            "id": "21673a1a-5415-49b9-bfc5-bd00f85e5108",
                            "text": "线程池"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "930390e8a43a",
                                    "text": "创建线程的几种方式"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "Runnable 接口不会返回结果或抛出检查异常，但是**Callable 接口**可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。\n",
                                    "id": "c763ba0c-c81a-4939-a5b9-0b886779cf78",
                                    "text": "Runnable 接口和 Callable 接口的区别"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\nsubmit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\n\n",
                                    "id": "bf06e36b-c933-4950-a890-9f20b9d39dbb",
                                    "text": "execute()方法和 submit()方法的区别"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "-`FixedThreadPool`和 `SingleThreadExecutor` ： 允许请求的队列长度为`Integer.MAX_VALUE`，可能堆积大量的请求，从而导致 OOM。\n\n-`CachedThreadPool` 和 `ScheduledThreadPool`： 允许创建的线程数量为`Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。",
                                    "id": "12e99fc89cd8",
                                    "text": "为什么不推荐使用Executors创建线程池"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "ThreadPoolExecutor\n| 参数            | 意义                       |\n| --------------- | -------------------------- |\n| corePoolSize    | 线程池常驻核心线程数       |\n| maximumPoolSize | 能够容纳的最大线程数       |\n| keepAliveTime   | 空闲线程存活时间           |\n| unit            | 存活时间单位               |\n| workQueue       | 存放提交但未执行任务的队列 |\n| threadFactory   | 创建线程的工厂类           |\n| handler         | 等待队列满后的拒绝策略     |",
                                    "id": "25f2b166-f005-4232-9686-58c27022f9c9",
                                    "text": "创建线程池的7个参数"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "当等待队列满时，且达到最大线程数，再有新任务到来，就需要启动拒绝策略。JDK提供了四种拒绝策略：\n1.ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。\n2.ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。\n3.ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务\n4.ThreadPoolExecutor.CallerRunsPolicy：由提交任务的线程直接处理该任务",
                                            "id": "c77bd7f6-515f-4a74-969b-35c574744067",
                                            "text": "ThreadPoolExecutor 拒绝策略"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210404034153-ojnt67e.png)",
                                            "id": "4dfd8426-9830-4a3c-adb2-e0d87d8bbe5c",
                                            "text": "执行图"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "1.一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。\n2.一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。\n3.线程等待IO时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 = ((线程等待IO时间+线程CPU时间)/线程CPU时间 )* CPU数目",
                                    "id": "ea85892695f1",
                                    "text": "线程池的线程数量怎么确定"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "5f23b6a9ad85",
                            "text": "锁"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "不是锁的类型，而是思想。",
                                    "id": "55b3bf58cd18",
                                    "text": "悲观锁与乐观锁"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "462b460e6a95",
                                    "text": "公平锁与非公平锁"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "228faffdfe32",
                                    "text": "可重入锁与不可重入锁"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "370cddd201f1",
                                    "text": "独占锁与共享锁"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "synchronized是悲观锁，独占锁，隐式锁，可重入锁，非公平锁。synchronized关键字可以保证被它修饰的方法或代码块在同一时刻只能有一个线程执行。它还可以保证共享变量在多线程下的可见性。\n",
                                    "id": "28a8890d-b76d-4e36-9438-990184fe8389",
                                    "text": "synchronized"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "1.修饰实例方法: 锁为当前对象，同时只能有一个线程访问该对象的同步方法\n2.修饰静态方法: 锁为当前类，同时只能有一个线程访问该类的同步方法\n3.修饰代码块：指定加锁对象，对给定对象/类加锁。\nsynchronized静态方法和 synchronized(类.class)代码块都是给 Class类上锁。\nsynchronized实例方法和synchronized(this)都是给对象实例上锁。\n尽量不要使用 synchronized(\"String\") 因为 JVM 中字符串常量池具有缓存功能！\n",
                                            "id": "fce9b35c-20e0-4c43-b9a4-e6e5a357306a",
                                            "text": "synchronized的三种使用方式"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "```java\npublic class Singleton{\n    private volatile static Singleton instance;\n    private Singleton(){};\n    public static Singleton getInstance(){\n        if(instance== null){\n            synchronized (Singleton.class){\n                if(instance== null){\n                     instance= new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n/**\ninstance = new Singleton(); 这段代码其实是分为三步执行：\n1.为instance分配内存空间  2.初始化instance  3.将instance指向分配的内存地址\n由于JVM具有指令重排的特性，执行顺序有可能变成1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程T1执行了1和3，此时T2调用getInstance()后发现instance不为空，因此返回instance，但此时instance还未被初始化。\n\n使用volatile可以禁止JVM 的指令重排，保证在多线程环境下也能正常运行。\n*/\n```\n\n",
                                            "id": "3db19f76-218b-4c35-abf7-41eef5ca71a0",
                                            "text": "线程安全的单例"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "从`.class`字节码中看到，synchronized代码块使用了1个`monitorenter` 和2个`monitorexit`指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则分别在同步代码块的结束位置和处理异常的开始位置，可知synchronized会在代码块执行完成或遇到异常时自动解锁。synchronized方法则是打了一个`ACC_SYNCHRONIZED` 标识，JVM 通过该标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n更深层次地说，synchronized 是基于 **Java 对象头**和 **Monitor 机制**实现的。\n\n\n",
                                            "id": "b2c16e3e-1d82-447d-9018-d361ca5a20f8",
                                            "text": "synchronized的底层原理"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意**锁可以升级不可降级**，这种策略是为了提高获得锁和释放锁的效率。\n| 锁       | 优点                                   | 缺点                                     |\n| -------- | -------------------------------------- | ---------------------------------------- |\n| 偏向锁   | 加锁和解锁无额外开销, 性能近似无锁状态 | 若线程间存在锁竞争, 撤销偏向锁有额外消耗 |\n| 轻量级锁 | 线程抢锁失败不阻塞, 提高了响应速度     | 自旋会消耗CPU                            |\n| 重量级锁 | 线程竞争失败不用自旋, 不会消耗CPU      | 线程阻塞，响应时间缓慢                   |\n\n其他：锁消除、锁粗化",
                                            "id": "25d3504f-1025-4f8b-8982-f884b064ee5d",
                                            "text": "锁的优化"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "e8c51ac26e03",
                                            "text": "锁的升级过程"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "1.只在必要的时候加锁\n2.减小锁粒度，就是缩小锁定对象的范围，降低锁冲突的可能性\n3.在读多写少的场合使用读写分离锁而不是独占锁\n4.锁粗化：如果一系列连续操作都对同一个对象反复加锁和解锁，把加锁的范围扩展到整个操作序列的外部",
                                    "id": "136d9e59d7b1",
                                    "text": "提高锁性能的几点建议"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "b1f09aebbc62",
                            "text": "CAS"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d7fab52ac486",
                                    "text": "CAS思想"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "108e46f68fa3",
                                    "text": "CAS底层实现"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d50939196d55",
                                    "text": "CAS重试机制"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "1） CPU开销过大\n在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。\n2） 不能保证代码块的原子性\nCAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。\n3） ABA问题\n这是CAS机制最大的问题所在。\n（当一个值从A变成B，又更新回A，普通CAS机制会误判通过检测。这里我们利用版本号比较可以有效解决ABA问题。在Java中，AtomicStampedReference类就实现了用版本号作比较额CAS机制。）\n",
                                            "id": "48e50434-6259-4653-a002-a5fbf2b57373",
                                            "text": "CAS的缺点"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "171d12de0f26",
                                    "text": "ABA问题"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "主存中的变量在各个线程中有一份本地缓存的副本。\n![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210405070659-gs0gswk.png)\n**如果要把一个变量从主存复制到工作内存：顺序执行 read 和 load 操作。**\n**如果要把一个变量从工作内存同步会主存：顺序执行 store 和 write 操作。**",
                            "id": "0c5c4001-0c01-4b49-a097-a78d1b4d03fb",
                            "text": "Java内存模型"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "原子性 ：一个或多个操作整体，要么全部成功，要么都不执行。synchronized或原子类\n可见性 ：一个线程对主内存的修改可以立即被其他线程知晓。\n有序性 ：代码执行时禁止指令重排。\n\nsynchronized和volatile可以保证可见性和有序性，且在这两个场景的底层语义相同。",
                                    "id": "b45bb956-2bcb-41ee-8f21-38e546b8b154",
                                    "text": "JMM三个重要特性"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "CPU cache用于解决 CPU 处理速度和内存不匹配的问题，内存缓存用于解决硬盘访问速度过慢的问题。",
                                    "id": "0ecfb743234e",
                                    "text": "为什么需要CPU高速缓存"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "JVM提供的**轻量级**同步机制，保证了共享变量在多线程下的**可见性**。\n\n普通变量和volatile变量的操作过程：\n\n![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210405061351-d6tu4bz.png)\n\nvolatile向CPU添加了lock指令，通过缓存一致性机制，保证了当一个线程通过总线修改主内存中的数据时，其他线程能够嗅探到更改，并使各自内部的缓存失效，要使用这个变量必须去主存获取最新值，并通过插入内存屏障来禁止指令重排序来保证有序性。volatile不能保证i++这种复合操作的原子性。",
                                    "id": "d7c7a8fdeeca",
                                    "text": "volatile底层原理"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "1.volatile主要解决共享变量在多线程下的**可见性**，synchronized主要解决多个线程访问临界资源的**互斥性**\n2.volatile只能用于变量，而 synchronized可以修饰方法以及代码块。\n3.volatile能保证数据的可见性和有序性，但不能保证原子性。synchronized则都能保证。\n4.volatile是线程同步的轻量级实现，**volatile在其适用场景的性能肯定比synchronized要好**。",
                                            "id": "27748b0d-ab94-49cb-a7b1-22cd535b1e9a",
                                            "text": "synchronized和volatile的区别"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "happens-before规则规定了不能指令重排的场景：\n\n*程序顺序原则：一个线程内保证语义的串行性。\n*volatile 规则：volatile 变量的写先于读发生，保证了这个变量的可见性。\n*一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n*Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。\n*一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。\n*Thread 对象的结束先行发生于 join() 方法返回。\n*对线程 interrupt() 方法的调用先行发生于被中断线程的代码，因此可以通过 interrupted() 方法检测到是否有中断发生。\n*如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。",
                                    "id": "605140731c9c",
                                    "text": "happens-before"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "1b5d2a563f9c",
                            "text": "j.u.c包"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "a74049d903ff",
                                    "text": "ReentrantLock"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "\n\n两者都是可重入锁\n\n“可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。\nsynchronized 依赖于 JVM 而 ReentrantLock 依赖于 API\n\nsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。\n\nReentrantLock 比 synchronized 增加了一些高级功能\n\n相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：\n\n等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\n可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。\n可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。\nCondition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。\n如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准\n\n",
                                            "id": "ef57408d-f224-4cf4-9bfb-9786777b5316",
                                            "text": "synchronized和ReentrantLock 的区别"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "9d12a1f74b46",
                                    "text": "Condition"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\nAQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\n状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作\n\n//返回同步状态的当前值\nprotected final int getState() {\n        return state;\n}\n // 设置同步状态的值\nprotected final void setState(int newState) {\n        state = newState;\n}\n//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n",
                                    "id": "974b4f0e-37c9-4e98-b2b0-3741e8deeefc",
                                    "text": "AQS"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "Exclusive（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁： \n公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 \n非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 \nShare（共享）：多个线程可同时执行，如 CountDownLatch、Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。 \nReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。 \n\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。\n",
                                            "id": "a297abf3-f99f-4c31-a950-afdb55ad54e4",
                                            "text": " AQS 对资源的共享方式"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\n\n使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）\n将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。\n\nAQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：\n\nisHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\n\n默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。\n\n以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。\n\n再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\n\n推荐两篇 AQS 原理和相关源码分析的文章：\n\nhttp://www.cnblogs.com/waterystone/p/4920797.html\nhttps://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\n",
                                            "id": "25440c99-0a7f-4dda-a906-32bdc747405a",
                                            "text": " AQS 底层使用了模板方法模式"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "6b978568-dfe4-49e0-abe7-8c2f65fa86ed",
                                            "text": "AQS 组件"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\n\n",
                                                    "id": "edcd1a9f-7a59-4821-a52b-3095a55adba0",
                                                    "text": "Semaphore(信号量)-允许多个线程同时访问"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "note": "CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。\n",
                                                    "id": "7465ea4b-de2e-4ec0-9a36-98f7ab3fab97",
                                                    "text": "CountDownLatch （倒计时器）"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "note": "CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 CountDownLatch 。具体场景是下面这样的：\n\n我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。\n\n为此我们定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。\n\n伪代码是下面这样的：\n\npublic class CountDownLatchExample1 {\n  // 处理文件的数量\n  private static final int threadCount = 6;\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\n    final CountDownLatch countDownLatch = new CountDownLatch(threadCount);\n    for (int i = 0; i < threadCount; i++) {\n      final int threadnum = i;\n      threadPool.execute(() -> {\n        try {\n          //处理文件的业务操作\n          ......\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        } finally {\n          //表示一个文件已经被完成\n          countDownLatch.countDown();\n        }\n\n      });\n    }\n    countDownLatch.await();\n    threadPool.shutdown();\n    System.out.println(\"finish\");\n  }\n\n}\n",
                                                            "id": "932070ae-80f3-4389-923e-9dd66a2f44da",
                                                            "text": "什么场景"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "data": {
                                                    "note": "CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\n",
                                                    "id": "51398997-13ca-4b7a-a40a-7228ae3ef457",
                                                    "text": "CyclicBarrier(循环栅栏)"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "c3bf65aa-b190-4bdc-992d-f34465db05a2",
                                    "text": "Atomic 原子类"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "**基本类型**：使用原子的方式更新基本类型\n\nAtomicInteger：整形原子类\nAtomicLong：长整型原子类\nAtomicBoolean：布尔型原子类\n**数组类型**：使用原子的方式更新数组元素\n\nAtomicIntegerArray：整形数组原子类\nAtomicLongArray：长整形数组原子类\nAtomicReferenceArray：引用类型数组原子类\n**引用类型**\n\nAtomicReference：引用类型原子类\nAtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\nAtomicMarkableReference ：原子更新带有标记位的引用类型\n**对象的属性修改类型**\n\nAtomicIntegerFieldUpdater：原子更新整形字段的更新器\nAtomicLongFieldUpdater：原子更新长整形字段的更新器\nAtomicReferenceFieldUpdater：原子更新引用类型字段的更新器\n",
                                            "id": "12e83003-02eb-4800-a0bf-84481958532f",
                                            "text": "JUC 包中的四类原子类"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\n \nCAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。java语言CAS底层利用unsafe提供的原子性操作方法。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。\n\n\nsynchronized属于悲观锁，悲观的认为程序中的并发情况严重，所以严防死守，CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。\n在java中除了上面提到的Atomic系列类，以及Lock系列类夺得底层实现，甚至在JAVA1.6以上版本，synchronized转变为重量级锁之前，也会采用CAS机制。\n",
                                            "id": "a8be86b5-fc26-467c-a3a4-4689c1aeefd9",
                                            "text": "Atomic类如何保证原子性（CAS操作)"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "note": "ThreadLocal提供了线程的**局部变量**，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，**实现了线程间的数据隔离**。主要应用场景：\n1.主要应用场景为管理多实例的访问，每个线程对应一个实例，并且这个实例在各个线程中很多地方都要用到。如在线程池应用场景中，每个线程对应一个数据库连接，线程内部对数据库的各种操作都与这个连接有关，而线程之间并无联系，使用ThreadLocal可以体现数据库事务的隔离性。\n2.减少参数传递，线程内部多个方法需要频繁传递一些context上下文，这些都需要通过参数传递，将这些上下文对象封装为ThreadLocal对象，就可以避免这些参数传递，在各个方法中使用ThreadLocal的get()方法即可。\n\n",
                            "id": "ce4f4d60-c245-4a33-8089-59ea15e22210",
                            "text": "ThreadLocal"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "每个线程中有一个`ThreadLocalMap`对象，ThreadLocalMap其实是ThreadLocal的一个内部类，调用ThreadLocal对象的`get()`和`set()`，其实都是作用到各个线程的ThreadLocalMap。这个map底层是一个`Entry`数组，用以保存多个ThreadLocal对象，每个Entry是一个键值对，key是ThreadLocal对象的**弱引用**，value是要set()的对象的**强引用**，hash冲突使用**线性探查法**处理。\n\nThreadLocal对象和ThreadLocalMap都存在堆中，线程的栈中只有ThreadLocal和当前Thread的引用。\n![image.png](https://b3logfile.com/siyuan/1616679307940/assets/image-20210406042732-hz9svrg.png)\n\n如果需要线程共享ThreadLocal对象，可以使用InheritableThreadLocal。",
                                    "id": "9f793aa4f2ff",
                                    "text": "ThreadLocal原理"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "ThreadLocalMap 中使用的 key 为 ThreadLocal对象的**弱引用**,而 value 是存入对象的**强引用**。当使用完ThreadLocal对象后，将其在栈中的强引用置为null，则只有一个弱引用的key指向该对象，一旦发生GC，key 指向的对象会被清理掉，而value指向的对象不会。从而在ThreadLocalMap中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，只要线程一直运行，value 永远无法被 GC 回收，导致内存泄露。因此使用完ThreadLocal对象后，记得调用remove()方法以避免内存泄漏。\n\n**key为什么要设计为弱引用，value为什么不设计为弱引用**：当删除栈中的ThreadLocal引用后，若map中的key是强引用，则和value一样会导致内存泄漏。而value指向的对象只有value一个引用，若为弱引用，一旦GC就将回收，则通过get()得到的都是null。\n\n另：可以看看netty的fastThreadLocal怎样弥补ThreadLocal存在的不足。",
                                    "id": "de3b60d4-cd74-4dc3-a50b-fb3d607c7337",
                                    "text": "ThreadLocal 内存泄露问题"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "fb22630003b0",
                            "text": "其他问题"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "分2种情况\n\n1.局部变量肯定是线程安全的（原因：方法内局部变量是线程私有的）\n2.成员变量多个线程共享时，就不是线程安全的(原因：成员变量是线程共享的，因为 i++ 是三步操作。)",
                                    "id": "41796655704c",
                                    "text": "i++是线程安全的吗"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "ce84d805ec73",
                                    "text": "实现生产者与消费者模型"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "c40ad37f-732b-47dd-87aa-121e5e702c96",
                    "text": "JVM",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "0bb30159-e0dd-4a57-acae-2628a4ff21f4",
                            "text": "运行时数据区<br>"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "       程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。\n      另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n \n从上面的介绍中我们知道程序计数器主要有两个作用：\n \n字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n \n注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\n",
                                    "id": "f13825bf-4fc2-4433-b916-715d36723181",
                                    "text": "程序计数器"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。\n",
                                    "id": "2163ec0d-1ae8-476b-b708-07e16ab74417",
                                    "text": "java虚拟机栈"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "9bca7513-ebe3-41b5-baf9-32150faa3959",
                                            "text": "逃逸分析"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\nOutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常异常。\n\n\n\n",
                                            "id": "a11a79cb-0248-4a8d-987d-d6f8a0547217",
                                            "text": "StackOverFlowError 和 OutOfMemoryError"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\n\n",
                                    "id": "01d9ee57-a313-4af2-b254-95606cf3f9eb",
                                    "text": "本地方法栈"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\nJava世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\n",
                                    "id": "6fb842fa-3066-46e9-8738-b29d75a016d5",
                                    "text": "堆"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。\n\n在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：\n\n新生代内存(Young Generation)\n老生代(Old Generation)\n永生代(Permanent Generation)\n￼\nJDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n￼\n上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。\n\n大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\n\n修正（issue552）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。\n\n动态年龄计算的代码如下\n\nuint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n\t//survivor_capacity是survivor空间的大小\n  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);\n  size_t total = 0;\n  uint age = 1;\n  while (age < table_size) {\n    total += sizes[age];//sizes数组是每个年龄段对象大小\n    if (total > desired_survivor_size) break;\n    age++;\n  }\n  uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;\n\t...\n}\n\n堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\nOutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\njava.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！)\n......\n",
                                            "id": "a69f4ad2-2887-4f5b-a648-ed8c893de435",
                                            "text": "堆的结构"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "note": "方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\n",
                                    "id": "cacd2420-ff05-4b91-b5cb-0a42455e0dce",
                                    "text": "方法区"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "b76bc5319349",
                                    "text": "运行时常量池"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "b687c5d5db02",
                            "text": "Hotspot虚拟机对象"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "0295228c-c0dc-4d71-b3aa-9d1bc0580cce",
                                    "text": "对象实例化过程"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "b09b72be1ba6",
                                    "text": "对象的内存布局"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "Mark Word:动态结构，根据对象状态复用存储空间\n\n类型指针：指向类型元数据\n\n数组长度：数组对象类型特有",
                                            "id": "ae67c3c9618a",
                                            "text": "对象头"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "真正存储对象实例数据的地方，主要是定义的字段内容",
                                            "id": "d451cbfc7eec",
                                            "text": "实例数据"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "当对象实例数据部分不是8字节的整数倍时，用占位符填充补齐。以保证任何对象的大小都是8字节的整数倍。",
                                            "id": "ffedb72364c8",
                                            "text": "对齐填充"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "be83edc92e5f",
                                    "text": "对象的访问定位"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "aa5df430-d748-4f42-a244-6bdd989d44e0",
                            "text": "JMM(Java的内存模型)"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "7058ee10-a683-4485-816c-fd3adf95321f",
                                    "text": " Java内存模型中的重排序"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "019a4c81-56f7-40ae-9dfe-8505255f6de1",
                                            "text": "volatile"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令：\n\n将当前处理器缓存行的数据写回到系统内存\n这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。",
                                                    "id": "9e348114-7cce-4c39-ab02-11774ac921c6",
                                                    "text": "volatile的实现原理"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "note": "volatile变量自身具有下列特性：\n\n可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。\n原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。",
                                                    "id": "0a5e9d79-3ccd-490f-988e-de2af5de988d",
                                                    "text": "volatile的内存语义"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "df571620-207c-4998-9f65-36cde975f729",
                                    "text": "Java内存模型带来的问题"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "b2ab9c6a-b1c1-4ab4-83c2-2ca901a91c38",
                                            "text": "可见性问题"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "b8f94b5f-e0c0-49be-935c-8cba80b2e21e",
                                            "text": "竞争现象"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "f0252a87-64fa-4059-939a-52208a976cc0",
                            "text": "类加载子系统"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "0ca073f8-bed3-4b46-b646-6dbf9b17141b",
                                    "text": "类加载器分类"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "3bf08960-f973-4410-9fe1-22c114799d91",
                                    "text": "双亲委派机制"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "f8be906f-9f98-4966-9103-8f476c997557",
                                    "text": "沙箱安全机制"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "c3bf799d-c54a-4c9e-9728-d2f27442baa8",
                            "text": "JDK 监控和故障处理"
                        },
                        "children": [
                            {
                                "data": {
                                    "note": "jps(JVM Process Status) 命令类似 UNIX 的 ps 命令。\n\njps：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。jps -q ：只输出进程的本地虚拟机唯一 ID。\n\nC:\\Users\\SnailClimb>jps\n7360 NettyClient2\n17396\n7972 Launcher\n16504 Jps\n17340 NettyServer\njps -l:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。\n\nC:\\Users\\SnailClimb>jps -l\n7360 firstNettyDemo.NettyClient2\n17396\n7972 org.jetbrains.jps.cmdline.Launcher\n16492 sun.tools.jps.Jps\n17340 firstNettyDemo.NettyServer\njps -v：输出虚拟机进程启动时 JVM 参数。\n\njps -m：输出传递给 Java 进程 main() 函数的参数。\n\n",
                                    "id": "82269328-a85e-4329-9638-1481967a8ae8",
                                    "text": "jps:查看所有 Java 进程"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。\n\njstat 命令使用格式：\n\njstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n比如 jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。\n\n常见的 option 如下：\n\njstat -class vmid ：显示 ClassLoader 的相关信息；\njstat -compiler vmid ：显示 JIT 编译的相关信息；\njstat -gc vmid ：显示与 GC 相关的堆信息；\njstat -gccapacity vmid ：显示各个代的容量及使用情况；\njstat -gcnew vmid ：显示新生代信息；\njstat -gcnewcapcacity vmid ：显示新生代大小与使用情况；\njstat -gcold vmid ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；\njstat -gcoldcapacity vmid ：显示老年代的大小；\njstat -gcpermcapacity vmid ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；\njstat -gcutil vmid ：显示垃圾收集信息；\n另外，加上 -t参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间\n\n",
                                    "id": "4cddfc87-b7a7-4a62-8494-56a4d43cacbe",
                                    "text": "jstat: 监视虚拟机各种运行状态信息"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "info vmid :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。\n\njinfo -flag name vmid :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails :详细 GC 日志模式，这两个都是默认关闭的)。\n\nC:\\Users\\SnailClimb>jinfo  -flag MaxHeapSize 17340\n-XX:MaxHeapSize=2124414976\nC:\\Users\\SnailClimb>jinfo  -flag PrintGC 17340\n-XX:-PrintGC\n使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：\n\njinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数。\n\nC:\\Users\\SnailClimb>jinfo  -flag  PrintGC 17340\n-XX:-PrintGC\n\nC:\\Users\\SnailClimb>jinfo  -flag  +PrintGC 17340\n\nC:\\Users\\SnailClimb>jinfo  -flag  PrintGC 17340\n-XX:+PrintGC\n",
                                    "id": "f4e60b49-4a95-4cfc-a177-834f2baf3d71",
                                    "text": "jinfo: 实时地查看和调整虚拟机各项参数"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "jmap（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。\n\njmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。\n\n示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。\n\nC:\\Users\\SnailClimb>jmap -dump:format=b,file=C:\\Users\\SnailClimb\\Desktop\\heap.hprof 17340\nDumping heap to C:\\Users\\SnailClimb\\Desktop\\heap.hprof ...\nHeap dump file created\n",
                                    "id": "0d493037-c2c0-4ab8-a03e-57f2cc28bf1a",
                                    "text": "jmap:生成堆转储快照"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "jhat 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。\n\nC:\\Users\\SnailClimb>jhat C:\\Users\\SnailClimb\\Desktop\\heap.hprof\nReading from C:\\Users\\SnailClimb\\Desktop\\heap.hprof...\nDump file created Sat May 04 12:30:31 CST 2019\nSnapshot read, resolving...\nResolving 131419 objects...\nChasing references, expect 26 dots..........................\nEliminating duplicate references..........................\nSnapshot resolved.\nStarted HTTP server on port 7000\nServer is ready.\n访问 http://localhost:7000/\n\n",
                                    "id": "cc62d08c-4aaa-4504-8cf9-214db8076e4d",
                                    "text": "jhat: 分析 heapdump 文件"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.\n\n生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。\n\n下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。\n\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\nOutput\n\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过 Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。\n\n通过 jstack 命令分析：\n\nC:\\Users\\SnailClimb>jps\n13792 KotlinCompileDaemon\n7360 NettyClient2\n17396\n7972 Launcher\n8932 Launcher\n9256 DeadLockDemo\n10764 Jps\n17340 NettyServer\n\nC:\\Users\\SnailClimb>jstack 9256\n输出的部分内容如下：\n\nFound one Java-level deadlock:\n=============================\n\"线程 2\":\n  waiting to lock monitor 0x000000000333e668 (object 0x00000000d5efe1c0, a java.lang.Object),\n  which is held by \"线程 1\"\n\"线程 1\":\n  waiting to lock monitor 0x000000000333be88 (object 0x00000000d5efe1d0, a java.lang.Object),\n  which is held by \"线程 2\"\n\nJava stack information for the threads listed above:\n===================================================\n\"线程 2\":\n        at DeadLockDemo.lambda$main$1(DeadLockDemo.java:31)\n        - waiting to lock <0x00000000d5efe1c0> (a java.lang.Object)\n        - locked <0x00000000d5efe1d0> (a java.lang.Object)\n        at DeadLockDemo$$Lambda$2/1078694789.run(Unknown Source)\n        at java.lang.Thread.run(Thread.java:748)\n\"线程 1\":\n        at DeadLockDemo.lambda$main$0(DeadLockDemo.java:16)\n        - waiting to lock <0x00000000d5efe1d0> (a java.lang.Object)\n        - locked <0x00000000d5efe1c0> (a java.lang.Object)\n        at DeadLockDemo$$Lambda$1/1324119927.run(Unknown Source)\n        at java.lang.Thread.run(Thread.java:748)\n\nFound 1 deadlock.\n可以看到 jstack 命令已经帮我们找到发生死锁的线程的具体信息。\n\n",
                                    "id": "ffe6c484-5b8e-48a2-b250-0b19c270a8fb",
                                    "text": "jstack :生成虚拟机当前时刻的线程快照（死锁可用此命令查看）"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出console命令启动或者在 JDK 目录下的 bin 目录找到jconsole.exe然后双击启动。连接 Jconsole\n\n￼\n如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:\n\n-Djava.rmi.server.hostname=外网访问 ip 地址 \n-Dcom.sun.management.jmxremote.port=60001   //监控的端口号\n-Dcom.sun.management.jmxremote.authenticate=false   //关闭认证\n-Dcom.sun.management.jmxremote.ssl=false\n在使用 JConsole 连接时，远程进程地址如下：\n\n外网访问 ip 地址:60001 \n\n查看 Java 程序概况\n\n￼内存监控\nJConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。\n\n点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。\n\n新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n￼线程监控\n类似我们前面讲的 jstack 命令，不过这个是可视化的。\n\n最下面有一个\"检测死锁 (D)\"按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。\n\n￼\n",
                                    "id": "e22fc09b-49ac-4ff8-8584-d45dc0a44d6c",
                                    "text": "JConsole:Java 监视与管理控制台"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "note": "VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：https://visualvm.github.io/ 。Visual VM 中文文档:https://visualvm.github.io/documentation.html。\n\n下面这段话摘自《深入理解 Java 虚拟机》。\n\nVisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。\nVisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：\n\n显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。\n监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。\ndump 以及分析堆转储快照（jmap、jhat）。\n方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。\n离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。\n其他 plugins 的无限的可能性......\n",
                                    "id": "36886a80-6456-414d-b34a-74b9f5be9140",
                                    "text": "Visual VM:多合一故障处理工具"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "3610709e-8c9b-43d2-ac79-2dfed33538fa",
                            "text": "GC"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "c3d1f9de-7c09-4fbb-a090-4ef68e55f05d",
                                    "text": "对象存活判断：垃圾标记"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "68d01edd-8022-40f7-b8ea-1d858a557de2",
                                            "text": "引用计数算法"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "bcbdb0ec-f00c-4fef-906c-7dc68ce35579",
                                            "text": "可达性分析算法（根搜索算法）"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "ed84047839b3",
                                    "text": "堆内存中对象分配的基本策略"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "93a37443-79bb-46fb-868f-253853b85965",
                                    "text": "常见的垃圾回收器"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "07545307-8876-47a5-92a7-3cae43ea5d7f",
                                    "text": "垃圾回收算法"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "f56b5508-c109-4148-9862-f93dec9c2901",
                                            "text": "标记清除算法"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "c4174cc9-b52f-47a7-a437-43a0db50f679",
                                            "text": "复制算法"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "fbf12052-f35c-4f40-8362-36185182ace9",
                                            "text": "标记压缩算法"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "77e94fe9-d8a0-4280-95b3-6b0dd4f78bbb",
                                            "text": "分代收集算法"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "7977c4d6-7638-4597-8f85-2f76ebd2e61d",
                                            "text": "增量收集算法"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "c9502045-f529-45d5-a667-def5eaebed1a",
                                            "text": "分区算法"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "c493254d-68cf-4d83-a800-90c88f84f532",
                                    "text": "java的不同引用"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "note": "强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。\n",
                                            "id": "365cc7eb-56f2-44cd-9f93-0d22b3beed19",
                                            "text": "强引用"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n\n所以，软引用可用来实现内存敏感的高速缓存。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n",
                                            "id": "1681a90f-2acf-482b-bc49-ab5d19e5cfaa",
                                            "text": "软引用"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "弱引用与软引用的区别在于：弱引用的对象拥有更短暂的生命周期。\n\n在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n",
                                            "id": "11a51356-838e-449f-8bf5-bef5179ef846",
                                            "text": "弱引用"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。\n\n如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n",
                                            "id": "ddf4acd5-8fbf-4b40-8154-0ed4387a85dd",
                                            "text": "虚引用"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "c6ad652a-35f6-41c4-a8d9-f7c2c7b59435",
                                            "text": "软引用，弱引用，虚引用的区别"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "note": "A、 GC无法删除存在强引用的对象的内存。\n\n\nB、 GC发现一个只有软引用的对象内存，那么：\n① SoftReference对象的referent 域被设置为null，从而使该对象不再引用heap对象。\n② SoftReference引用过的heap对象被声明为finalizable。\n③ 当 heap 对象的 finalize() 方法被运行而且该对象占用的内存被释放，SoftReference 对象就被添加到它的 ReferenceQueue（如果后者存在的话）。\n\n\nC、 GC发现一个只有弱引用的对象内存，那么：\n① WeakReference对象的referent域被设置为null,从而使该对象不再引用heap对象。\n② WeakReference引用过的heap对象被声明为finalizable。\n③ 当heap对象的finalize()方法被运行而且该对象占用的内存被释放时，WeakReference对象就被添加到它的ReferenceQueue（如果后者存在的话）。\n\n\nD、 GC发现一个只有虚引用的对象内存，那么：\n① PhantomReference引用过的heap对象被声明为finalizable。\n② PhantomReference在堆对象被释放之前就被添加到它的ReferenceQueue。\n",
                                            "id": "de5b191f-3608-4162-b4e9-1afff9513c52",
                                            "text": "GC、Reference与ReferenceQueue的交互"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "f148e7a2-38c9-42df-bba0-6bb6c05b0cea",
                                    "text": "内存溢出，内存泄露"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "8f3bbec8-0d9d-4636-bf74-5d12d57e9310",
                                    "text": "分代收集"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "7cc7a8e5-7671-4b50-a349-8c80aee867a0",
                                            "text": "young（minor） gc/old（major） gc"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "53f5e067-a849-43e7-b9bb-10fa40fec275",
                                            "text": "full gc"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "note": "1.调用System.gc（）时，系统建议执行Full GC，但是不必然执行。\n2.老年代空间不足时。\n3.方法区空间不足时。\n4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。\n5.由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。",
                                                    "id": "d485a3f8-8dd8-4adc-85c8-87789c7686a3",
                                                    "text": "触发条件"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "fresh-blue-compat",
    "version": "1.4.43"
}